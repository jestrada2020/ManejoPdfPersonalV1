<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herramientas PDF Avanzadas</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --bg-body: #f3f4f6;
            --bg-card: #ffffff;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 0.5rem;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 80vh;
        }

        header {
            background-color: #fff;
            padding: 20px;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--text-main);
            font-weight: 600;
        }

        .tabs {
            display: flex;
            background: #f9fafb;
            border-bottom: 1px solid var(--border);
        }

        .tab-btn {
            flex: 1;
            padding: 15px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-muted);
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover {
            color: var(--primary);
            background-color: #f3f4f6;
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background-color: #fff;
        }

        .tab-content {
            display: none;
            padding: 30px;
            flex: 1;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-main);
        }

        input[type="text"],
        input[type="number"],
        input[type="password"],
        input[type="file"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 0.95rem;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 24px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
        }

        .btn:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Specific Lists */
        .file-list {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }

        .file-list li {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            background: #fff;
        }

        .file-list li:last-child {
            border-bottom: none;
        }

        .file-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .file-name {
            font-weight: 500;
        }

        .file-password {
            font-size: 0.85rem;
        }

        .file-password input {
            padding: 4px 8px;
            width: 150px;
            font-size: 0.8rem;
        }

        .btn-remove {
            background: #fee2e2;
            color: #ef4444;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .btn-remove:hover {
            background: #fecaca;
        }

        .result-area {
            margin-top: 20px;
            padding: 15px;
            background: #ecfdf5;
            border: 1px solid #a7f3d0;
            border-radius: var(--radius);
            color: #065f46;
            text-align: center;
            display: none;
        }

        .result-area a {
            color: #059669;
            font-weight: 600;
            text-decoration: none;
        }

        .result-area a:hover {
            text-decoration: underline;
        }

        .row {
            display: flex;
            gap: 15px;
        }

        .col {
            flex: 1;
        }

        .logs {
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-muted);
            max-height: 100px;
            overflow-y: auto;
            border-top: 1px solid var(--border);
            padding-top: 10px;
        }

        /* Annotation Toolbar & Viewer */
        .toolbar {
            display: flex;
            gap: 10px;
            padding: 10px;
            background: #f3f4f6;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            align-items: center;
            border-right: 1px solid #d1d5db;
            padding-right: 10px;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .tool-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            background: none;
            cursor: pointer;
        }

        #pdfViewerContainer {
            width: 100%;
            height: 600px;
            overflow: auto;
            border: 1px solid var(--border);
            background: #525659;
            /* Darker bg for contrast */
            position: relative;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        #pageContainer {
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        #pdfCanvas {
            display: block;
            background: white;
        }

        #annotationLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .modal-content {
            background-color: #fefefe;
            padding: 20px;
            border: 1px solid #888;
            width: 95%;
            height: 90%;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
            cursor: pointer;
            z-index: 1001;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Adjust viewer container for modal */
        #pdfViewerContainer {
            height: auto;
            flex-grow: 1;
            background: #525659;
            margin-top: 10px;
        }

        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
        }

        .textLayer>span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        .textLayer ::selection {
            background: rgba(0, 0, 255, 1);
            color: transparent;
        }

        .sidebar-controls {
            width: 250px;
            background: #f1f1f1;
            padding: 15px;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .recording-active {
            animation: pulse-red 2s infinite;
            background-color: #ffcccc;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>Herramientas PDF Profesional</h1>
        </header>

        <div class="tabs">
            <button class="tab-btn" onclick="switchTab('merge')">Unir PDFs</button>
            <button class="tab-btn" onclick="switchTab('extract')">Extraer por Rango</button>
            <button class="tab-btn" onclick="switchTab('search')">Extraer por B√∫squeda</button>
            <button class="tab-btn" onclick="switchTab('chapters')">Extracci√≥n de Cap√≠tulos</button>
            <button class="tab-btn" onclick="switchTab('unlock')">Desbloquear PDF</button>
            <button class="tab-btn" onclick="switchTab('annotate')">Anotar / Revisar</button>
            <button class="tab-btn" onclick="switchTab('media')">A√±adir Videos / Audio</button>
            <button class="tab-btn" onclick="switchTab('translate')">Traductor / Lector</button>
            <button class="tab-btn" onclick="switchTab('podcast')">Podcast</button>
            <button class="tab-btn" onclick="switchTab('tts-podcast')">Texto a Podcast</button>
        </div>

        <!-- MERGE TAB -->
        <div id="merge" class="tab-content active">
            <div class="form-group">
                <label>1. Seleccionar Archivos (Ordenados)</label>
                <input type="file" id="mergeFilesInput" accept="application/pdf" multiple style="margin-bottom: 10px;">
                <ul id="mergeList" class="file-list"></ul>
                <p class="logs" id="mergeLogs">A√±ade archivos para comenzar.</p>
            </div>

            <div class="form-group">
                <label>2. Nombre del archivo final</label>
                <input type="text" id="mergeOutputName" placeholder="pdf_unido.pdf" value="pdf_unido.pdf">
            </div>

            <button id="mergeBtn" class="btn" disabled onclick="mergePDFs()">Unir PDFs Seleccionados</button>

            <div id="mergeResult" class="result-area">
                ¬°√âxito! <a id="mergeDownload" href="#" download>Descargar PDF Unido</a>
            </div>
        </div>

        <!-- EXTRACT TAB -->
        <div id="extract" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo PDF</label>

                <input type="file" id="extractFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('extract')">
                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('extractFileInput').click()">
                    üìÇ Cargar PDF (Extraer)
                </button>

                <div id="extractFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="extractFileName" style="font-weight:bold;"></span>
                    <div style="margin-top: 8px;">
                        <input type="password" id="extractFilePass" placeholder="Contrase√±a (si tiene)">
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <div class="form-group">
                        <label>P√°gina Inicio</label>
                        <input type="number" id="startPage" min="1" value="1">
                    </div>
                </div>
                <div class="col">
                    <div class="form-group">
                        <label>P√°gina Final</label>
                        <input type="number" id="endPage" min="1" value="1">
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="rasterizeMode" style="width:auto; margin-right:10px;">
                    <span>Modo Compatibilidad (Imprimir como Imagen)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    √öselo si recibe errores de contrase√±a o si el archivo est√° protegido. Esto convertir√° las p√°ginas en
                    im√°genes.
                </small>
            </div>

            <div class="form-group">
                <label>Nombre del archivo final</label>
                <input type="text" id="extractOutputName" placeholder="paginas_extraidas.pdf"
                    value="paginas_extraidas.pdf">
            </div>

            <button id="extractBtn" class="btn" disabled onclick="extractPages()">Extraer P√°ginas</button>

            <div id="extractResult" class="result-area">
                ¬°√âxito! <a id="extractDownload" href="#" download>Descargar PDF Extra√≠do</a>
            </div>
        </div>

        <!-- SEARCH TAB -->
        <div id="search" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo PDF</label>

                <input type="file" id="searchFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('search')">
                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('searchFileInput').click()">
                    üìÇ Cargar PDF (B√∫squeda)
                </button>

                <div id="searchFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="searchFileName" style="font-weight:bold;"></span>
                    <div style="margin-top: 8px;">
                        <input type="password" id="searchFilePass" placeholder="Contrase√±a (si tiene)">
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>2. Texto a buscar</label>
                <input type="text" id="searchQuery" placeholder="Ej: Cap√≠tulo 1, Referencia #123...">
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    La b√∫squeda es inteligente: no distingue may√∫sculas/min√∫sculas ni acentos.
                </small>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="searchRasterMode" style="width:auto; margin-right:10px;">
                    <span>Modo Compatibilidad (Imprimir como Imagen)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    √öselo si recibe errores o si el archivo est√° protegido. Esto convertir√° las p√°ginas en im√°genes.
                </small>
            </div>

            <div class="form-group">
                <label>Nombre del archivo final</label>
                <input type="text" id="searchOutputName" placeholder="busqueda_resultado.pdf"
                    value="busqueda_resultado.pdf">
            </div>

            <button id="searchBtn" class="btn" disabled onclick="searchAndExtract()">Buscar P√°ginas</button>
            <p class="logs" id="searchLogs"></p>

            <!-- Preview de p√°ginas encontradas -->
            <div id="searchPreview"
                style="display:none; margin-top: 20px; padding: 15px; background: #f9fafb; border: 1px solid var(--border); border-radius: var(--radius);">
                <h3 style="margin-top: 0; font-size: 1.1rem; color: var(--text-main);">P√°ginas encontradas:</h3>
                <div id="searchPagesList" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;"></div>
                <button id="extractFoundBtn" class="btn" onclick="extractFoundPages()" style="margin-right: 10px;">
                    Extraer P√°ginas Seleccionadas
                </button>
                <button class="btn" onclick="cancelSearch()" style="background: #6b7280;">
                    Cancelar
                </button>
            </div>

            <div id="searchResult" class="result-area">
                ¬°√âxito! <a id="searchDownload" href="#" download>Descargar PDF Resultante</a>
            </div>
        </div>

        <!-- CHAPTERS TAB -->
        <div id="chapters" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo PDF</label>

                <input type="file" id="chaptersFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('chapters')">
                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('chaptersFileInput').click()">
                    üìÇ Cargar PDF (Cap√≠tulos)
                </button>

                <div id="chaptersFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="chaptersFileName" style="font-weight:bold;"></span>
                    <div style="margin-top: 8px;">
                        <input type="password" id="chaptersFilePass" placeholder="Contrase√±a (si tiene)">
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>2. Patr√≥n de detecci√≥n de cap√≠tulos</label>
                <input type="text" id="chapterPattern" placeholder='Ej: Cap√≠tulo, Chapter, CAP√çTULO'
                    value="Cap√≠tulo,Chapter,CAP√çTULO">
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    Ingrese las palabras clave separadas por comas. El sistema detectar√° cap√≠tulos autom√°ticamente.
                </small>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="chapterUseNumbers" checked style="width:auto; margin-right:10px;">
                    <span>Detectar solo cap√≠tulos numerados (Cap√≠tulo 1, Cap√≠tulo 2, etc.)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    Recomendado para evitar falsos positivos. Desmarque para detectar todos los cap√≠tulos.
                </small>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="chapterRasterMode" style="width:auto; margin-right:10px;">
                    <span>Modo Compatibilidad (Imprimir como Imagen)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    √öselo si recibe errores o si el archivo est√° protegido.
                </small>
            </div>

            <button id="chaptersBtn" class="btn" disabled onclick="detectChapters()">Detectar Cap√≠tulos</button>
            <p class="logs" id="chaptersLogs"></p>

            <!-- Preview de cap√≠tulos detectados -->
            <div id="chaptersPreview"
                style="display:none; margin-top: 20px; padding: 15px; background: #f9fafb; border: 1px solid var(--border); border-radius: var(--radius);">
                <h3 style="margin-top: 0; font-size: 1.1rem; color: var(--text-main);">Cap√≠tulos detectados:</h3>
                <div id="chaptersList" style="margin-bottom: 15px; max-height: 300px; overflow-y: auto;"></div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="extractAllChaptersBtn" class="btn" onclick="extractAllChapters()">
                        üìö Extraer Todos los Cap√≠tulos
                    </button>
                    <button class="btn" onclick="cancelChapters()" style="background: #6b7280;">
                        Cancelar
                    </button>
                </div>
            </div>

            <div id="chaptersResult" class="result-area">
                <p id="chaptersResultText">¬°√âxito! Se han generado los cap√≠tulos.</p>
                <div id="chaptersDownloadLinks" style="margin-top: 10px;"></div>
            </div>
        </div>

        <!-- UNLOCK TAB -->
        <div id="unlock" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo
                    Protegido</label>

                <input type="file" id="unlockFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('unlock')">
                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('unlockFileInput').click()">
                    üîê Cargar PDF (Desbloquear)
                </button>

                <div id="unlockFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="unlockFileName" style="font-weight:bold;"></span>
                    <div style="margin-top: 8px;">
                        <input type="password" id="unlockFilePass" placeholder="Contrase√±a (opcional si no tiene)">
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="unlockRasterMode" style="width:auto; margin-right:10px;">
                    <span>Modo Avanzado (Renderizar como Im√°genes)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    Use este modo si el PDF tiene restricciones que no se pueden eliminar normalmente.
                    El archivo resultante ser√° m√°s grande pero estar√° completamente desbloqueado.
                    Este modo procesa en lotes para optimizar la memoria.
                </small>
            </div>

            <div class="form-group">
                <label style="display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="unlockLowMemoryMode" style="width:auto; margin-right:10px;">
                    <span>Modo Ahorro de Memoria (Para PDFs muy grandes)</span>
                </label>
                <small style="color: var(--text-muted); display: block; margin-top: 4px;">
                    Active esta opci√≥n si est√° procesando un PDF con muchas p√°ginas (>100).
                    El proceso ser√° m√°s lento pero usar√° menos memoria.
                </small>
            </div>

            <div class="form-group">
                <label>Nombre del archivo final (Desbloqueado)</label>
                <input type="text" id="unlockOutputName" placeholder="archivo_desbloqueado.pdf"
                    value="archivo_desbloqueado.pdf">
            </div>

            <button id="unlockBtn" class="btn" disabled onclick="unlockPDF()">Desbloquear PDF</button>
            <p class="logs" id="unlockLogs"></p>

            <div id="unlockResult" class="result-area">
                ¬°√âxito! <a id="unlockDownload" href="#" download>Descargar PDF Desbloqueado</a>
            </div>
        </div>

        <!-- ANNOTATE TAB -->
        <div id="annotate" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo PDF</label>

                <input type="file" id="annotateFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('annotate')">

                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('annotateFileInput').click()">
                    üìÇ Cargar PDF (Anotar)
                </button>

                <div id="annotateFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="annotateFileName" style="font-weight:bold;"></span>
                </div>
            </div>

            <button id="annotateBtn" class="btn" disabled onclick="startAnnotation()">
                ‚úèÔ∏è Comenzar Revisi√≥n
            </button>

            <div id="annotateResult" class="result-area">
                ¬°√âxito! <a id="annotateDownload" href="#" download>Descargar PDF Anotado</a>
            </div>
        </div>

        <!-- MEDIA TAB -->
        <div id="media" class="tab-content">
            <div class="form-group"
                style="text-align: center; padding: 20px; background: white; border: 2px dashed var(--border); border-radius: 8px;">
                <label style="font-size: 1.1rem; margin-bottom: 10px; display:block;">1. Seleccionar Archivo PDF</label>

                <input type="file" id="mediaFileInput" accept="application/pdf" style="display: none;"
                    onchange="handleSingleFileSelect('media')">

                <button class="btn" style="max-width: 250px; margin: 0 auto;"
                    onclick="document.getElementById('mediaFileInput').click()">
                    üìÇ Cargar PDF (Multimedia)
                </button>

                <div id="mediaFileInfo"
                    style="display:none; margin-top: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; text-align: left;">
                    <span id="mediaFileName" style="font-weight:bold;"></span>
                </div>
            </div>

            <button id="mediaBtn" class="btn" disabled onclick="startAnnotation('media')">
                üé¨ A√±adir Multimedia
            </button>

            <div id="mediaResult" class="result-area">
                ¬°√âxito! <a id="mediaDownload" href="#" download>Descargar PDF Multimedia</a>
            </div>
        </div>

        <!-- TRANSLATE / READER TAB -->
        <div id="translate" class="tab-content" style="height: calc(100vh - 160px);">
            <div style="display: flex; height: 100%;">
                <!-- Sidebar -->
                <div class="sidebar-controls">
                    <h3>Traductor / Lector</h3>

                    <button class="btn" style="width:100%; margin-bottom:10px;"
                        onclick="document.getElementById('translateFileInput').click()">
                        üìÇ Cargar PDF
                    </button>
                    <input type="file" id="translateFileInput" accept="application/pdf" style="display: none;"
                        onchange="handleTranslateFileBase(this)">

                    <hr>

                    <label><b>Zoom / Vista:</b></label>
                    <div style="display:flex; gap:5px; margin-bottom: 10px;">
                        <button class="btn" style="flex:1; font-size: 0.8rem;" onclick="setTranslateZoom('fit')">Ajustar
                            Ancho</button>
                        <button class="btn" style="width: 30px;" onclick="changeTranslateZoom(0.2)">+</button>
                        <button class="btn" style="width: 30px;" onclick="changeTranslateZoom(-0.2)">-</button>
                    </div>

                    <label><b>1. Traducci√≥n</b></label>
                    <label>Idioma destino:</label>
                    <select id="transLang" class="form-control">
                        <option value="es">Espa√±ol</option>
                        <option value="en">Ingl√©s</option>
                        <option value="fr">Franc√©s</option>
                        <option value="de">Alem√°n</option>
                        <option value="it">Italiano</option>
                        <option value="pt">Portugu√©s</option>
                        <option value="zh-CN">Chino</option>
                        <option value="ja">Japon√©s</option>
                    </select>
                    <button class="btn" onclick="translateSelection()">Traducir Selecci√≥n</button>

                    <hr>

                    <label><b>2. Lectura (TTS)</b></label>
                    <label>Voz:</label>
                    <select id="ttsVoice" class="form-control" onchange="previewVoice()">
                        <option value="">Cargando voces...</option>
                    </select>

                    <label>Velocidad:</label>
                    <input type="range" id="ttsRate" min="0.5" max="2" step="0.1" value="1">

                    <div style="display:flex; gap:5px; margin-top:5px;">
                        <button class="btn" onclick="speakSelection()" style="flex:1;">‚ñ∂Ô∏è Leer</button>
                        <button class="btn" onclick="stopSpeech()" style="flex:1;">‚èπÔ∏è Parar</button>
                    </div>
                </div>

                <!-- Viewer -->
                <div
                    style="flex:1; background: #525659; overflow: auto; position: relative; display: flex; justify-content: center; padding: 20px;">
                    <div id="translateWrapper" style="position: relative;">
                        <canvas id="translateCanvas" style="display:block; border: 1px solid black;"></canvas>
                        <div id="textLayer" class="textLayer"></div>
                    </div>
                </div>
            </div>

            <!-- Floating Page Controls for this tab -->
            <div
                style="position: absolute; bottom: 20px; left: 280px; background: white; padding: 5px 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                <button onclick="changeTranslatePage(-1)">‚èÆÔ∏è</button>
                <span id="transPageLabel">1 / 1</span>
                <button onclick="changeTranslatePage(1)">‚è≠Ô∏è</button>
            </div>
        </div>

        <!-- PODCAST TAB -->
        <div id="podcast" class="tab-content" style="height: calc(100vh - 160px);">
            <div style="display: flex; height: 100%;">
                <!-- Sidebar -->
                <div class="sidebar-controls">
                    <h3>Podcast Studio</h3>

                    <!-- File Load -->
                    <button class="btn" style="width:100%; margin-bottom:10px;"
                        onclick="document.getElementById('podcastFileInput').click()">
                        üìÇ Cargar PDF
                    </button>
                    <input type="file" id="podcastFileInput" accept="application/pdf" style="display: none;"
                        onchange="handlePodcastFileBase(this)">

                    <hr>

                    <label><b>1. Grabadora</b></label>
                    <div
                        style="text-align:center; border: 1px solid #ccc; padding: 10px; border-radius: 5px; background: white;">
                        <canvas id="audioVisualizer" width="200" height="50"
                            style="width:100%; height:50px; background:#222; margin-bottom:5px;"></canvas>
                        <div id="recordTimer" style="font-size: 1.2rem; font-weight: bold; margin-bottom: 5px;">00:00
                        </div>

                        <div style="display:flex; gap:5px; justify-content: center;">
                            <button id="btnRecordStart" class="btn" onclick="startRecording()"
                                style="background: #d32f2f; color: white;">üî¥ Grabar</button>
                            <button id="btnRecordStop" class="btn" onclick="stopRecording()" disabled>‚èπÔ∏è Parar</button>
                        </div>
                    </div>

                    <div id="audioPreviewContainer" style="margin-top: 10px; display:none;">
                        <label>Pre-escucha:</label>
                        <audio id="audioPreview" controls style="width: 100%;"></audio>
                        <button class="btn" onclick="useRecordedAudio()"
                            style="width:100%; margin-top:5px; background:#4CAF50; color:white;">‚úÖ Usar Audio</button>
                    </div>

                    <hr>
                    <label><b>O subir archivo:</b></label>
                    <input type="file" id="uploadAudioInput" accept="audio/*" onchange="handleAudioUpload(this)">

                    <hr>
                    <label><b>2. Insertar</b></label>
                    <p style="font-size:0.8rem; color:#666;">El audio se adjuntar√° al PDF. Haz clic en "Colocar" y luego
                        en la p√°gina para a√±adir el icono.</p>
                    <button id="btnPlacePodcast" class="btn" disabled onclick="activatePodcastPlacement()">üìç Colocar en
                        PDF</button>

                    <hr>
                    <button id="btnSavePodcast" class="btn" disabled onclick="savePodcastPDF()">üíæ Guardar PDF</button>

                </div>

                <!-- Viewer -->
                <div
                    style="flex:1; background: #525659; overflow: auto; position: relative; display: flex; justify-content: center; padding: 20px;">
                    <div id="podcastWrapper" style="position: relative;">
                        <canvas id="podcastCanvas"
                            style="display:block; border: 1px solid black; cursor: default;"></canvas>
                        <!-- No overlay needed for placement, standard canvas events -->
                    </div>
                </div>
            </div>

            <!-- Floating Page Controls for this tab -->
            <div
                style="position: absolute; bottom: 20px; left: 280px; background: white; padding: 5px 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                <button onclick="changePodcastPage(-1)">‚èÆÔ∏è</button>
                <span id="podcastPageLabel">1 / 1</span>
                <button onclick="changePodcastPage(1)">‚è≠Ô∏è</button>
            </div>
        </div>


        <!-- TTS PODCAST TAB -->
        <div id="tts-podcast" class="tab-content" style="height: calc(100vh - 160px);">
            <div style="display: flex; height: 100%;">
                <!-- Sidebar -->
                <div class="sidebar-controls">
                    <h3>Texto a Podcast</h3>

                    <!-- File Load -->
                    <button class="btn" style="width:100%; margin-bottom:10px;"
                        onclick="document.getElementById('ttsPodcastFileInput').click()">
                        üìÇ Cargar PDF
                    </button>
                    <input type="file" id="ttsPodcastFileInput" accept="application/pdf" style="display: none;"
                        onchange="handleTTSPodcastFileBase(this)">

                    <hr>

                    <label><b>1. Texto:</b></label>
                    <textarea id="ttsInputText" rows="6" style="width:100%; resize:vertical; padding:5px;"
                        placeholder="Escribe aqu√≠ el texto para convertir a audio..."></textarea>

                    <label>Idioma:</label>
                    <select id="ttsLang" class="form-control">
                        <option value="es">Espa√±ol</option>
                        <option value="en">Ingl√©s</option>
                        <option value="fr">Franc√©s</option>
                        <option value="de">Alem√°n</option>
                    </select>

                    <button class="btn" onclick="generateTTSAudio()"
                        style="margin-top:10px; background:#673ab7; color:white;">
                        üîä Generar Audio
                    </button>

                    <div id="ttsAudioPreviewContainer" style="margin-top: 10px; display:none;">
                        <label>Pre-escucha:</label>
                        <audio id="ttsAudioPreview" controls style="width: 100%;"></audio>
                    </div>

                    <hr>
                    <label><b>2. Insertar</b></label>
                    <p style="font-size:0.8rem; color:#666;">Haz clic en "Colocar" y luego selecciona el lugar en el
                        PDF.</p>
                    <button id="btnPlaceTTSPodcast" class="btn" disabled onclick="activateTTSPodcastPlacement()">
                        üìç Colocar en PDF
                    </button>

                    <hr>
                    <button id="btnSaveTTSPodcast" class="btn" disabled onclick="saveTTSPodcastPDF()">
                        üíæ Guardar PDF
                    </button>

                </div>

                <!-- Viewer -->
                <div
                    style="flex:1; background: #525659; overflow: auto; position: relative; display: flex; justify-content: center; padding: 20px;">
                    <div id="ttsPodcastWrapper" style="position: relative;">
                        <canvas id="ttsPodcastCanvas"
                            style="display:block; border: 1px solid black; cursor: default;"></canvas>
                    </div>
                </div>
            </div>

            <!-- Floating Page Controls for this tab -->
            <div
                style="position: absolute; bottom: 20px; left: 280px; background: white; padding: 5px 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                <button onclick="changeTTSPodcastPage(-1)">‚èÆÔ∏è</button>
                <span id="ttsPodcastPageLabel">1 / 1</span>
                <button onclick="changeTTSPodcastPage(1)">‚è≠Ô∏è</button>
            </div>
        </div>

        <!-- MODAL FOR ANNOTATION -->
        <div id="annotationModal" class="modal">
            <div class="modal-content">
                <span class="close-modal" onclick="closeModal()">&times;</span>

                <div class="toolbar">
                    <!-- ANNOTATION TOOLS -->
                    <div class="toolbar-group" id="annotationTools">
                        <button class="tool-btn active" onclick="setTool('cursor')" id="btnToolCursor"
                            title="Cursor (Mover)">üñ±Ô∏è</button>
                        <button class="tool-btn" onclick="setTool('highlight')" id="btnToolHighlight"
                            title="Resaltar">üñçÔ∏è</button>
                        <button class="tool-btn" onclick="setTool('underline')" id="btnToolUnderline"
                            title="Subrayar">UÃ≤</button>
                        <button class="tool-btn" onclick="setTool('strikethrough')" id="btnToolStrike"
                            title="Tachar">SÃ∂</button>
                        <button class="tool-btn" onclick="setTool('text')" id="btnToolText" title="Texto">T</button>
                        <button class="tool-btn" onclick="setTool('note')" id="btnToolNote" title="Nota">üìù</button>
                        <button class="tool-btn" onclick="setTool('arrow')" id="btnToolArrow" title="Flecha">‚ûú</button>
                        <button class="tool-btn" onclick="setTool('rectangle')" id="btnToolRect"
                            title="Rect√°ngulo">‚ñ≠</button>
                        <button class="tool-btn" onclick="setTool('circle')" id="btnToolCircle"
                            title="C√≠rculo">‚≠ï</button>
                        <button class="tool-btn" onclick="setTool('draw')" id="btnToolDraw" title="Dibujar">‚úèÔ∏è</button>
                        <button class="tool-btn" onclick="setTool('eraser')" id="btnToolEraser"
                            title="Borrador (Clic en anotaci√≥n)">üßπ</button>
                    </div>

                    <!-- MEDIA TOOLS -->
                    <div class="toolbar-group" id="mediaTools" style="display:none;">
                        <button class="tool-btn active" onclick="setTool('cursor')" id="btnToolCursorMedia"
                            title="Cursor">üñ±Ô∏è</button>
                        <button class="tool-btn" onclick="setTool('youtube')" id="btnToolYouTube"
                            title="Video YouTube">üì∫
                            Video</button>
                        <button class="tool-btn" onclick="setTool('audio')" id="btnToolAudio" title="Audio Link">üîä
                            Audio</button>
                        <button class="tool-btn" onclick="setTool('link')" id="btnToolLink" title="Enlace Web">üîó
                            Enlace</button>
                        <button class="tool-btn" onclick="setTool('eraser')" id="btnToolEraserMedia"
                            title="Borrador">üßπ</button>
                    </div>
                    <div class="toolbar-group">
                        <label style="margin:0; font-size:0.85rem;">Color:</label>
                        <input type="color" id="toolColor" value="#ffeb3b" class="color-picker">
                        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:2px;">
                            <button class="tool-btn" onclick="setQuickColor('#ffeb3b')"
                                style="background:#ffeb3b; width:20px; height:20px; padding:0;"
                                title="Amarillo"></button>
                            <button class="tool-btn" onclick="setQuickColor('#ff6b6b')"
                                style="background:#ff6b6b; width:20px; height:20px; padding:0;" title="Rojo"></button>
                            <button class="tool-btn" onclick="setQuickColor('#4ecdc4')"
                                style="background:#4ecdc4; width:20px; height:20px; padding:0;" title="Azul"></button>
                            <button class="tool-btn" onclick="setQuickColor('#95e1d3')"
                                style="background:#95e1d3; width:20px; height:20px; padding:0;" title="Verde"></button>
                            <button class="tool-btn" onclick="setQuickColor('#a78bfa')"
                                style="background:#a78bfa; width:20px; height:20px; padding:0;" title="Morado"></button>
                            <button class="tool-btn" onclick="setQuickColor('#fb923c')"
                                style="background:#fb923c; width:20px; height:20px; padding:0;"
                                title="Naranja"></button>
                            <button class="tool-btn" onclick="setQuickColor('#000000')"
                                style="background:#000000; width:20px; height:20px; padding:0;" title="Negro"></button>
                            <button class="tool-btn" onclick="setQuickColor('#ffffff')"
                                style="background:#ffffff; border:1px solid #ccc; width:20px; height:20px; padding:0;"
                                title="Blanco"></button>
                        </div>
                    </div>
                    <div class="toolbar-group">
                        <label style="margin:0; font-size:0.85rem;">Fuente:</label>
                        <select id="toolFont" style="font-size:0.85rem; padding:4px; width: 100px;">
                            <option value="Helvetica">Helvetica</option>
                            <option value="Helvetica-Bold">Helvetica Bold</option>
                            <option value="Helvetica-Oblique">Helvetica Italic</option>
                            <option value="Helvetica-BoldOblique">Helvetica Bold Italic</option>
                            <option value="Times-Roman">Times</option>
                            <option value="Times-Bold">Times Bold</option>
                            <option value="Times-Italic">Times Italic</option>
                            <option value="Times-BoldItalic">Times Bold Italic</option>
                            <option value="Courier">Courier</option>
                            <option value="Courier-Bold">Courier Bold</option>
                            <option value="Courier-Oblique">Courier Italic</option>
                            <option value="Courier-BoldOblique">Courier Bold Italic</option>
                        </select>
                        <select id="toolSize" style="font-size:0.85rem; padding:4px; width:50px;" title="Tama√±o Texto">
                            <option value="8">8pt</option>
                            <option value="10">10pt</option>
                            <option value="12" selected>12pt</option>
                            <option value="14">14pt</option>
                            <option value="16">16pt</option>
                            <option value="18">18pt</option>
                            <option value="24">24pt</option>
                            <option value="32">32pt</option>
                        </select>
                        <select id="toolWidth" style="font-size:0.85rem; padding:4px; width:70px;" title="Grosor L√≠nea">
                            <option value="1">Fino</option>
                            <option value="2" selected>Normal</option>
                            <option value="4">Grueso</option>
                            <option value="8">Marcador</option>
                        </select>
                    </div>
                    <div class="toolbar-group">
                        <input type="number" id="pageNumberInput" value="1" min="1"
                            style="width: 50px; text-align: center; padding: 4px; margin: 0 5px;"
                            onchange="jumpToPage(this.value)">
                        <span id="pageTotalLabel" style="font-size:0.9rem;">/ 1</span>
                        <button class="tool-btn" onclick="changePage(1)" title="P√°gina siguiente">‚è≠Ô∏è</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="tool-btn" onclick="undoAnnotation()" title="Deshacer"
                            style="font-weight:bold;">‚Ü∂</button>
                        <button class="tool-btn" onclick="clearPageAnnotations()" title="Limpiar p√°gina"
                            style="color:#ef4444;">üóëÔ∏è</button>
                    </div>
                    <div class="toolbar-group" style="margin-left:auto;">
                        <button class="tool-btn" style="background:#dbeafe; color:#1e40af; border-color:#93c5fd;"
                            onclick="saveAnnotations()">üíæ Guardar PDF</button>
                        <button class="tool-btn" style="background:#fee2e2; color:#ef4444; border-color:#fca5a5;"
                            onclick="closeModal()">Cerrar</button>
                    </div>
                </div>

                <div id="pdfViewerContainer">
                    <div id="pageContainer">
                        <canvas id="pdfCanvas"></canvas>
                        <canvas id="annotationLayer"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // --- Global Config ---
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // --- Tab Logic ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

            document.getElementById(tabId).classList.add('active');
            // Find button that calls this function with tabId and active it
            const buttons = document.querySelectorAll('.tab-btn');
            if (tabId === 'merge') buttons[0].classList.add('active');
            if (tabId === 'extract') buttons[1].classList.add('active');
            if (tabId === 'search') buttons[2].classList.add('active');
            if (tabId === 'chapters') buttons[3].classList.add('active');
            if (tabId === 'unlock') buttons[4].classList.add('active');
            if (tabId === 'annotate') buttons[5].classList.add('active');
            if (tabId === 'media') buttons[6].classList.add('active');
            if (tabId === 'translate') buttons[7].classList.add('active');
            if (tabId === 'podcast') buttons[8].classList.add('active');
            if (tabId === 'tts-podcast') buttons[9].classList.add('active');
        }

        // --- Helper Functions ---
        async function readPdfBytes(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        async function loadPdfWithPasswordFallback(bytes, password) {
            try {
                // Try loading with password if provided
                if (password) {
                    return await PDFLib.PDFDocument.load(bytes, { password, ignoreEncryption: false });
                } else {
                    // Try without password first
                    return await PDFLib.PDFDocument.load(bytes, { ignoreEncryption: false });
                }
            } catch (e) {
                console.error("Error loading PDF:", e);

                // Check if it's a password-related error
                if (e.message && (e.message.includes('password') || e.message.includes('encrypted') ||
                    e.message.includes('PasswordException'))) {
                    if (!password) {
                        throw new Error("Este PDF est√° protegido con contrase√±a. Por favor, ingrese la contrase√±a.");
                    } else {
                        throw new Error("Contrase√±a incorrecta. Por favor, verifique e intente nuevamente.");
                    }
                }

                // For other errors
                throw new Error("Error al cargar el PDF: " + (e.message || "Archivo corrupto o no v√°lido"));
            }
        }

        function triggerDownload(pdfBytes, filename, linkId, resultArea) {
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const link = document.getElementById(linkId);
            link.href = url;
            link.download = filename;
            resultArea.style.display = 'block';
        }

        // --- UNLOCK LOGIC ---
        async function unlockPDF() {
            const input = document.getElementById('unlockFileInput');
            if (!input.files.length) return;

            const file = input.files[0];
            const password = document.getElementById('unlockFilePass').value || '';
            const outputName = document.getElementById('unlockOutputName').value || 'desbloqueado.pdf';
            const useRasterMode = document.getElementById('unlockRasterMode').checked;
            const useLowMemoryMode = document.getElementById('unlockLowMemoryMode').checked;

            const btn = document.getElementById('unlockBtn');
            const resultArea = document.getElementById('unlockResult');
            const logs = document.getElementById('unlockLogs');

            btn.disabled = true;
            btn.textContent = "Desbloqueando...";
            resultArea.style.display = 'none';
            logs.textContent = "Iniciando proceso de desbloqueo...";

            // Configurar par√°metros de memoria seg√∫n el modo
            window.PDF_MEMORY_CONFIG = {
                lowMemoryMode: useLowMemoryMode,
                batchSize: useLowMemoryMode ? 3 : 5,
                copyBatchSize: useLowMemoryMode ? 5 : 10,
                scale: useLowMemoryMode ? 1.2 : 1.5,
                imageQuality: useLowMemoryMode ? 0.85 : 0.92,
                waitTime: useLowMemoryMode ? 100 : 50
            };

            try {
                const bytes = await readPdfBytes(file);

                if (useRasterMode) {
                    // MODO AVANZADO: Renderizar p√°ginas como im√°genes
                    logs.textContent = useLowMemoryMode ?
                        "Usando modo avanzado con ahorro de memoria..." :
                        "Usando modo avanzado (renderizaci√≥n)...";
                    await unlockByRasterization(bytes, password, outputName, logs, resultArea);
                } else {
                    // MODO NORMAL: Intentar m√∫ltiples estrategias
                    logs.textContent = "Intentando desbloquear con m√©todo est√°ndar...";
                    await unlockByStandardMethod(bytes, password, outputName, logs, resultArea);
                }

            } catch (error) {
                console.error("Unlock error:", error);
                logs.textContent = "Error: " + error.message;

                // Si el modo normal fall√≥, ofrecer usar modo avanzado autom√°ticamente
                if (!useRasterMode) {
                    const useAdvanced = confirm(
                        "Error en el modo est√°ndar: " + error.message +
                        "\n\n¬øDesea intentar con el Modo Avanzado autom√°ticamente?\n\n" +
                        "El Modo Avanzado renderiza las p√°ginas como im√°genes y funciona con cualquier PDF protegido."
                    );

                    if (useAdvanced) {
                        try {
                            logs.textContent = "Reintentando con Modo Avanzado...";
                            btn.textContent = "Procesando en Modo Avanzado...";
                            await unlockByRasterization(bytes, password, outputName, logs, resultArea);
                        } catch (advError) {
                            console.error("Advanced mode error:", advError);
                            logs.textContent = "Error en Modo Avanzado: " + advError.message;
                            alert("Error: " + advError.message);
                        }
                    }
                } else {
                    alert("Error: " + error.message);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = "Desbloquear PDF";
            }
        }

        // M√©todo est√°ndar con m√∫ltiples estrategias
        async function unlockByStandardMethod(bytes, password, outputName, logs, resultArea) {
            let pdfDoc = null;
            let strategy = '';
            let useSimpleSave = false;

            // Estrategia 1: Sin contrase√±a
            if (!password || password.trim() === '') {
                logs.textContent = "Estrategia 1: Intentando sin contrase√±a...";
                try {
                    pdfDoc = await PDFLib.PDFDocument.load(bytes, { ignoreEncryption: false });
                    strategy = 'sin contrase√±a';
                    useSimpleSave = true; // No hay encriptaci√≥n, guardar directo
                } catch (e) {
                    console.log("Estrategia 1 fall√≥:", e.message);
                }
            }

            // Estrategia 2: Con contrase√±a proporcionada
            if (!pdfDoc && password) {
                logs.textContent = "Estrategia 2: Usando contrase√±a proporcionada...";
                try {
                    pdfDoc = await PDFLib.PDFDocument.load(bytes, { password: password, ignoreEncryption: false });
                    strategy = 'con contrase√±a';
                    useSimpleSave = false; // Hay contrase√±a, necesitamos recrear
                } catch (e) {
                    console.log("Estrategia 2 fall√≥:", e.message);
                }
            }

            // Estrategia 3: Ignorar encriptaci√≥n sin contrase√±a
            if (!pdfDoc && !password) {
                logs.textContent = "Estrategia 3: Intentando ignorar encriptaci√≥n...";
                try {
                    pdfDoc = await PDFLib.PDFDocument.load(bytes, { ignoreEncryption: true });
                    strategy = 'ignorando encriptaci√≥n';
                    useSimpleSave = false;
                } catch (e) {
                    console.log("Estrategia 3 fall√≥:", e.message);
                }
            }

            // Estrategia 4: Ignorar encriptaci√≥n con contrase√±a
            if (!pdfDoc && password) {
                logs.textContent = "Estrategia 4: Combinando contrase√±a con ignoreEncryption...";
                try {
                    pdfDoc = await PDFLib.PDFDocument.load(bytes, { password: password, ignoreEncryption: true });
                    strategy = 'contrase√±a + ignorar encriptaci√≥n';
                    useSimpleSave = false;
                } catch (e) {
                    console.log("Estrategia 4 fall√≥:", e.message);
                }
            }

            // Estrategia 5: Contrase√±a vac√≠a expl√≠cita
            if (!pdfDoc) {
                logs.textContent = "Estrategia 5: Intentando con contrase√±a vac√≠a...";
                try {
                    pdfDoc = await PDFLib.PDFDocument.load(bytes, { password: '', ignoreEncryption: true });
                    strategy = 'contrase√±a vac√≠a';
                    useSimpleSave = false;
                } catch (e) {
                    console.log("Estrategia 5 fall√≥:", e.message);
                }
            }

            if (!pdfDoc) {
                throw new Error("No se pudo abrir el PDF. Intente con el 'Modo Avanzado' activado.");
            }

            logs.textContent = `PDF cargado exitosamente (${strategy}). Creando documento desbloqueado...`;

            let pdfBytes;

            // Verificar si el PDF tiene contenido
            const pageCount = pdfDoc.getPageCount();
            console.log(`PDF tiene ${pageCount} p√°ginas`);

            if (useSimpleSave) {
                // Si no hab√≠a encriptaci√≥n, simplemente guardar sin opciones de seguridad
                logs.textContent = "Guardando PDF sin restricciones (m√©todo directo)...";
                pdfBytes = await pdfDoc.save({
                    useObjectStreams: false,
                    addDefaultPage: false
                });
            } else {
                // Si hab√≠a encriptaci√≥n, crear nuevo documento y copiar p√°ginas
                logs.textContent = "Creando nuevo PDF sin restricciones...";
                const newPdf = await PDFLib.PDFDocument.create();

                // Copiar metadata
                const title = pdfDoc.getTitle();
                const author = pdfDoc.getAuthor();
                const subject = pdfDoc.getSubject();
                const keywords = pdfDoc.getKeywords();

                if (title) newPdf.setTitle(title);
                if (author) newPdf.setAuthor(author);
                if (subject) newPdf.setSubject(subject);
                if (keywords) newPdf.setKeywords(keywords);

                // Copiar p√°ginas en lotes para mejor gesti√≥n de memoria
                const pageIndices = pdfDoc.getPageIndices();
                const totalPagesToCopy = pageIndices.length;
                const config = window.PDF_MEMORY_CONFIG || { copyBatchSize: 10, waitTime: 30 };
                const COPY_BATCH_SIZE = config.copyBatchSize;

                logs.textContent = `Copiando ${totalPagesToCopy} p√°ginas (lotes de ${COPY_BATCH_SIZE})...`;

                for (let i = 0; i < totalPagesToCopy; i += COPY_BATCH_SIZE) {
                    const endIndex = Math.min(i + COPY_BATCH_SIZE, totalPagesToCopy);
                    const batchIndices = pageIndices.slice(i, endIndex);
                    logs.textContent = `Copiando p√°ginas ${i + 1}-${endIndex} de ${totalPagesToCopy}... (${Math.round(endIndex / totalPagesToCopy * 100)}%)`;
                    const copiedPages = await newPdf.copyPages(pdfDoc, batchIndices);
                    copiedPages.forEach(page => newPdf.addPage(page));

                    // Liberar memoria cada lote
                    if (endIndex < totalPagesToCopy) { await waitAndClearMemory(config.waitTime || 30); }
                }
                logs.textContent = "Guardando PDF sin restricciones...";
                // Liberar memoria antes de guardar
                await waitAndClearMemory(100);
                pdfBytes = await newPdf.save({ useObjectStreams: false, addDefaultPage: false });
            }

            // Verificar que el PDF generado no est√© vac√≠o
            if (!pdfBytes || pdfBytes.length === 0) {
                throw new Error("Error: El PDF generado est√° vac√≠o. Use el 'Modo Avanzado'.");
            }

            console.log(`PDF desbloqueado generado: ${pdfBytes.length} bytes`);
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('unlockDownload');
            link.href = url;
            link.download = outputName;
            resultArea.style.display = 'block';
            logs.textContent = `¬°√âxito! PDF desbloqueado (${pageCount} p√°ginas) usando: ${strategy}`;

        }

        // Funci√≥n para liberar memoria
        function forceGarbageCollection() {
            // Forzar limpieza de memoria
            if (window.gc) { window.gc(); }
        }

        // Funci√≥n para esperar y liberar memoria
        function waitAndClearMemory(ms = 10) {
            return new Promise(resolve => {
                setTimeout(() => {
                    forceGarbageCollection();
                    resolve();
                }, ms);
            });
        }

        // M√©todo por rasterizaci√≥n (convierte a im√°genes) - OPTIMIZADO PARA MEMORIA
        async function unlockByRasterization(bytes, password, outputName, logs, resultArea) {
            logs.textContent = "Cargando PDF para renderizar...";

            const loadingTask = pdfjsLib.getDocument({
                data: bytes,
                password: password || undefined,
                // Optimizaciones de memoria para PDF.js
                disableAutoFetch: true,
                disableStream: false,
                disableRange: false
            });

            const pdfJsDoc = await loadingTask.promise;
            const totalPages = pdfJsDoc.numPages;

            logs.textContent = `Renderizando ${totalPages} p√°ginas como im√°genes...`;

            const newPdf = await PDFLib.PDFDocument.create();

            // Obtener configuraci√≥n de memoria
            const config = window.PDF_MEMORY_CONFIG || {
                batchSize: 5,
                scale: 1.5,
                imageQuality: 0.92,
                waitTime: 50,
                lowMemoryMode: false
            };

            const BATCH_SIZE = config.batchSize;
            const SCALE = config.scale;
            const QUALITY = config.imageQuality;
            const WAIT_TIME = config.waitTime;

            logs.textContent = `Renderizando ${totalPages} p√°ginas (escala ${SCALE}, calidad ${Math.round(QUALITY *
                100)}%)...`;

            // Crear un solo canvas reutilizable
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', {
                willReadFrequently: false,
                alpha: false // Optimizaci√≥n de memoria
            });

            for (let i = 1; i <= totalPages; i++) {
                try {
                    const percentage = Math.round(i / totalPages * 100);
                    logs.textContent = `Procesando p√°gina ${i}/${totalPages}... (${percentage}%)`;
                    const page = await pdfJsDoc.getPage(i);
                    const viewport = page.getViewport({ scale: SCALE });

                    // Redimensionar canvas (reutilizar en vez de crear nuevo)
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    // Limpiar canvas antes de renderizar
                    context.clearRect(0, 0, canvas.width, canvas.height);

                    // Renderizar p√°gina
                    await page.render({ canvasContext: context, viewport: viewport }).promise;

                    // Convertir a imagen con calidad optimizada
                    const imgDataUrl = canvas.toDataURL('image/jpeg', QUALITY);

                    // Convertir DataURL a bytes
                    const response = await fetch(imgDataUrl);
                    const imgBytes = await response.arrayBuffer();

                    // Embeber imagen
                    const jpegImage = await newPdf.embedJpg(imgBytes);
                    const newPage = newPdf.addPage([viewport.width, viewport.height]);
                    newPage.drawImage(jpegImage, {
                        x: 0,
                        y: 0,
                        width: viewport.width,
                        height: viewport.height,
                    });

                    // Limpiar p√°gina procesada
                    page.cleanup();

                    // Cada BATCH_SIZE p√°ginas, hacer una pausa para liberar memoria
                    if (i % BATCH_SIZE === 0) {
                        logs.textContent = `Liberando memoria... (${i}/${totalPages} - ${percentage}%)`;
                        await waitAndClearMemory(WAIT_TIME);
                    }
                } catch (pageError) {
                    console.error(`Error procesando p√°gina ${i}:`, pageError);
                    logs.textContent = `Advertencia: Error en p√°gina ${i}, continuando...`;
                    await waitAndClearMemory(WAIT_TIME * 2);
                }
            }

            // Limpiar canvas
            canvas.width = 0;
            canvas.height = 0;
            logs.textContent = "Guardando PDF desbloqueado...";

            // Liberar memoria antes de guardar
            await waitAndClearMemory(100);

            const pdfBytes = await newPdf.save({
                useObjectStreams: false,
                addDefaultPage: false
            });

            // Liberar documento original
            pdfJsDoc.destroy();
            logs.textContent = "Generando descarga...";

            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('unlockDownload');
            link.href = url;
            link.download = outputName;
            resultArea.style.display = 'block';
            logs.textContent = `¬°√âxito! PDF desbloqueado (${totalPages} p√°ginas) mediante renderizaci√≥n.`;

            // √öltima limpieza de memoria
            forceGarbageCollection();
        } // --- MERGE LOGIC --- let mergeFiles=[];
        document.getElementById('mergeFilesInput').addEventListener('change', (e) => {
            const newFiles = Array.from(e.target.files).map(f => ({
                file: f,
                password: ''
            }));
            mergeFiles = [...mergeFiles, ...newFiles];
            renderMergeList();
            updateMergeBtnState();
            e.target.value = ''; // Reset to allow adding same file again
        });

        function renderMergeList() {
            const list = document.getElementById('mergeList');
            list.innerHTML = '';
            mergeFiles.forEach((item, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                <div class="file-info">
                    <span class="file-name">${item.file.name}</span>
                    <div class="file-password">
                        <input type="password" placeholder="Contrase√±a (opcional)" value="${item.password}"
                            oninput="updateMergePassword(${index}, this.value)">
                    </div>
                </div>
                <button class="btn-remove" onclick="removeMergeFile(${index})">Eliminar</button>
                `;
                list.appendChild(li);
            });
        }

        function updateMergePassword(index, val) {
            mergeFiles[index].password = val;
        }

        function removeMergeFile(index) {
            mergeFiles.splice(index, 1);
            renderMergeList();
            updateMergeBtnState();
        }

        function updateMergeBtnState() {
            document.getElementById('mergeBtn').disabled = mergeFiles.length < 2;
            const msg = mergeFiles.length === 0 ? "A√±ade archivos para comenzar." : `${mergeFiles.length} archivos listos.`;
            document.getElementById('mergeLogs').textContent = msg;
        }

        async function mergePDFs() {
            const btn = document.getElementById('mergeBtn');
            const logs = document.getElementById('mergeLogs');
            const resultArea = document.getElementById('mergeResult');

            btn.disabled = true;
            btn.textContent = "Procesando...";
            resultArea.style.display = 'none';
            logs.textContent = "Iniciando uni√≥n...";

            try {
                const newPdf = await PDFLib.PDFDocument.create();

                for (let i = 0; i < mergeFiles.length; i++) {
                    const item = mergeFiles[i];
                    logs.textContent = `Procesando archivo ${i + 1}/${mergeFiles.length}: ${item.file.name}...`;

                    const bytes = await readPdfBytes(item.file);
                    let pdfDoc;

                    try {
                        pdfDoc = await loadPdfWithPasswordFallback(bytes, item.password);
                    } catch (e) {
                        throw new Error(`Fallo al abrir ${item.file.name}. ¬øRequiere contrase√±a?`);
                    }

                    const copiedPages = await newPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
                    copiedPages.forEach(p => newPdf.addPage(p));
                }

                logs.textContent = "Generando archivo final...";
                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                const link = document.getElementById('mergeDownload');
                link.href = url;
                link.download = document.getElementById('mergeOutputName').value || 'unido.pdf';

                resultArea.style.display = 'block';
                logs.textContent = "¬°Completado!";

            } catch (error) {
                alert(error.message);
                logs.textContent = "Error: " + error.message;
            } finally {
                btn.disabled = false;
                btn.textContent = "Unir PDFs Seleccionados";
            }
        }

        // --- RANGE EXTRACT LOGIC ---
        let singleFile = null;

        function handleSingleFileSelect(tab) {
            const input = document.getElementById(tab + 'FileInput');
            const info = document.getElementById(tab + 'FileInfo');
            const nameSpan = document.getElementById(tab + 'FileName');
            const btn = document.getElementById(tab + 'Btn');

            if (input.files.length > 0) {
                info.style.display = 'block';
                nameSpan.textContent = input.files[0].name;
                btn.disabled = false;
            } else {
                info.style.display = 'none';
                btn.disabled = true;
            }
        }

        async function extractPages() {
            const input = document.getElementById('extractFileInput');
            if (!input.files.length) return;

            const file = input.files[0];
            const password = document.getElementById('extractFilePass').value;
            const start = parseInt(document.getElementById('startPage').value);
            const end = parseInt(document.getElementById('endPage').value);
            const outputName = document.getElementById('extractOutputName').value || 'extracto.pdf';
            const useRasterize = document.getElementById('rasterizeMode').checked;

            const btn = document.getElementById('extractBtn');
            const resultArea = document.getElementById('extractResult');

            if (isNaN(start) || isNaN(end) || start < 1 || end < start) {
                alert("Rango de p√°ginas inv√°lido.");
                return;
            }

            btn.disabled = true;
            btn.textContent = useRasterize ? "Procesando como Im√°genes..." : "Procesando...";
            resultArea.style.display = 'none';

            try {
                const bytes = await readPdfBytes(file);

                if (useRasterize) {
                    // --- RASTERIZATION MODE (Compatibilidad) ---
                    // Use PDF.js to render pages to canvas, then embed in new PDF
                    const loadingTask = pdfjsLib.getDocument({ data: bytes, password: password });
                    const pdfJsDoc = await loadingTask.promise;
                    const totalPages = pdfJsDoc.numPages;

                    if (end > totalPages) throw new Error(`El PDF solo tiene ${totalPages} p√°ginas.`);

                    const newPdf = await PDFLib.PDFDocument.create();

                    for (let i = start; i <= end; i++) {
                        const page = await pdfJsDoc.getPage(i);
                        const scale = 2; // Higher scale = better quality
                        const viewport = page.getViewport({ scale: scale });

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;

                        const imgDataUrl = canvas.toDataURL('image/png');
                        const imgBytes = await fetch(imgDataUrl).then(res => res.arrayBuffer());
                        const pngImage = await newPdf.embedPng(imgBytes);

                        const newPage = newPdf.addPage([viewport.width / scale * 72 / 72, viewport.height / scale * 72 / 72]);
                        newPage.setSize(viewport.width, viewport.height);
                        newPage.drawImage(pngImage, { x: 0, y: 0, width: viewport.width, height: viewport.height });
                    }

                    const pdfBytes = await newPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);

                    const link = document.getElementById('extractDownload');
                    link.href = url;
                    link.download = outputName;
                    resultArea.style.display = 'block';

                } else {
                    // --- NORMAL MODE ---
                    const pdfDoc = await loadPdfWithPasswordFallback(bytes, password);
                    const totalPages = pdfDoc.getPageCount();

                    if (end > totalPages) {
                        alert(`El PDF solo tiene ${totalPages} p√°ginas.`);
                        return;
                    }

                    const newPdf = await PDFLib.PDFDocument.create();
                    const rangeIndices = [];
                    for (let i = start; i <= end; i++) rangeIndices.push(i - 1);

                    const copiedPages = await newPdf.copyPages(pdfDoc, rangeIndices);
                    copiedPages.forEach(p => newPdf.addPage(p));

                    const pdfBytes = await newPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);

                    const link = document.getElementById('extractDownload');
                    link.href = url;
                    link.download = outputName;
                    resultArea.style.display = 'block';
                }

            } catch (error) {
                alert("Error: " + error.message);
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.textContent = "Extraer P√°ginas";
            }
        }


        // --- ANNOTATION LOGIC ---
        let annotState = {
            pdfDoc: null,
            file: null,
            totalPages: 0,
            currentPage: 1,
            scale: 1.5,
            tool: 'cursor',
            color: '#ffeb3b',
            font: 'Helvetica',
            fontSize: 12,
            lineWidth: 2,
            mode: 'annotate', // 'annotate' or 'media'
            annotations: [],
            isDrawing: false,
            startX: 0,
            startY: 0,
            drawPoints: []
        };

        function setTool(tool) {
            annotState.tool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const toolMap = {
                'cursor': 'btnToolCursor',
                'highlight': 'btnToolHighlight',
                'underline': 'btnToolUnderline',
                'strikethrough': 'btnToolStrike',
                'text': 'btnToolText',
                'note': 'btnToolNote',
                'arrow': 'btnToolArrow',
                'rectangle': 'btnToolRect',
                'circle': 'btnToolCircle',
                'arrow': 'btnToolArrow',
                'rectangle': 'btnToolRect',
                'circle': 'btnToolCircle',
                'draw': 'btnToolDraw',
                'eraser': 'btnToolEraser',
                'eraserMedia': 'btnToolEraserMedia',
                'youtube': 'btnToolYouTube',
                'audio': 'btnToolAudio',
                'link': 'btnToolLink',
                'cursorMedia': 'btnToolCursorMedia'
            };

            if (toolMap[tool]) {
                const btnId = toolMap[tool];
                // Handle duplicate tools for different modes
                if (tool === 'eraser') {
                    if (annotState.mode === 'media')
                        document.getElementById('btnToolEraserMedia').classList.add('active');
                    else document.getElementById('btnToolEraser').classList.add('active');
                } else if (tool === 'cursor') {
                    if (annotState.mode === 'media')
                        document.getElementById('btnToolCursorMedia').classList.add('active');
                    else document.getElementById('btnToolCursor').classList.add('active');
                } else {
                    const el = document.getElementById(btnId);
                    if (el) el.classList.add('active');
                }
            }

            const layer = document.getElementById('annotationLayer');
            layer.style.cursor = tool === 'cursor' ? 'default' : 'crosshair';
        }

        function updateToolbarVisibility() {
            const annotTools = document.getElementById('annotationTools');
            const mediaTools = document.getElementById('mediaTools');

            if (annotState.mode === 'media') {
                annotTools.style.display = 'none';
                mediaTools.style.display = 'flex';
            } else {
                annotTools.style.display = 'flex';
                mediaTools.style.display = 'none';
            }
        }

        function setQuickColor(color) {
            annotState.color = color;
            document.getElementById('toolColor').value = color;
        }

        function undoAnnotation() {
            const pageAnnotations = annotState.annotations.filter(a => a.page ===
                annotState.currentPage);
            if (pageAnnotations.length > 0) {
                const lastAnnotation = pageAnnotations[pageAnnotations.length - 1];
                const index = annotState.annotations.indexOf(lastAnnotation);
                annotState.annotations.splice(index, 1);
                redrawAnnotations();
            }
        }

        function clearPageAnnotations() {
            if (confirm('¬øLimpiar todas las anotaciones de esta p√°gina?')) {
                annotState.annotations = annotState.annotations.filter(a => a.page !==
                    annotState.currentPage);
                redrawAnnotations();
            }
        }

        document.getElementById('toolColor').addEventListener('input', (e) => {
            annotState.color = e.target.value;
        });

        document.getElementById('toolFont').addEventListener('change', (e) => {
            annotState.font = e.target.value;
        });

        document.getElementById('toolSize').addEventListener('change', (e) => {
            annotState.fontSize = parseInt(e.target.value);
        });

        document.getElementById('toolWidth').addEventListener('change', (e) => {
            annotState.lineWidth = parseInt(e.target.value);
        });

        async function startAnnotation(mode = 'annotate') {
            const inputId = mode === 'media' ? 'mediaFileInput' : 'annotateFileInput';
            const input = document.getElementById(inputId);

            if (!input.files.length) return;
            annotState.file = input.files[0];
            annotState.mode = mode;

            try {
                const bytes = await readPdfBytes(annotState.file);
                // Robust loading for both array buffer and Uint8Array
                const loadingTask = pdfjsLib.getDocument({ data: bytes });
                annotState.pdfDoc = await loadingTask.promise;
                annotState.totalPages = annotState.pdfDoc.numPages;
                annotState.currentPage = 1;
                annotState.annotations = [];

                // Update Tools UI
                updateToolbarVisibility();
                setTool('cursor');

                // Open Modal
                document.getElementById('annotationModal').style.display = 'flex';
                renderPage(annotState.currentPage);
            } catch (e) {
                console.error(e);
                alert("Error al cargar PDF: " + e.message);
            }
            // Reset input so change event fires again if same file selected
            input.value = '';
        }
        function closeModal() {
            document.getElementById('annotationModal').style.display = 'none';
        }

        async function changePage(delta) {
            if (!annotState.pdfDoc) return;
            const newPage = annotState.currentPage + delta;
            if (newPage >= 1 && newPage <= annotState.totalPages) {
                annotState.currentPage = newPage;
                renderPage(newPage);
            }
        }

        async function jumpToPage(val) {
            const pageNum = parseInt(val);
            if (pageNum >= 1 && pageNum <= annotState.totalPages) {
                annotState.currentPage = pageNum;
                renderPage(pageNum);
            } else {
                // Restore if invalid
                document.getElementById('pageNumberInput').value = annotState.currentPage;
            }
        }

        async function renderPage(pageNum) {
            if (!annotState.pdfDoc) return;

            document.getElementById('pageNumberInput').value = pageNum;
            document.getElementById('pageTotalLabel').textContent = `/ ${annotState.totalPages}`;

            const page = await annotState.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: annotState.scale });

            const canvas = document.getElementById('pdfCanvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const layer = document.getElementById('annotationLayer');
            layer.height = viewport.height;
            layer.width = viewport.width;

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            redrawAnnotations();
        }

        // --- Annotation Event Handlers ---
        // Ensure these are attached only once or handled globally. 
        // For simplicity in this fix, we attach them once in init or ensure idempotency.
        // But since we are replacing the block, let's attach them properly.
        // Note: The original code attached them inside renderPage which was bad. 
        // We will attach them to the layer element here, assuming layer exists.

        const layer = document.getElementById('annotationLayer');
        if (layer) {
            // Remove old listeners to be safe if this runs multiple times (though index.html is loaded once)
            layer.removeEventListener('mousedown', handleMouseDown);
            layer.removeEventListener('mousemove', handleMouseMove);
            layer.removeEventListener('mouseup', handleMouseUp);

            layer.addEventListener('mousedown', handleMouseDown);
            layer.addEventListener('mousemove', handleMouseMove);
            layer.addEventListener('mouseup', handleMouseUp);
        }

        function handleMouseDown(e) {
            if (annotState.tool === 'cursor') return;
            const rect = document.getElementById('annotationLayer').getBoundingClientRect();
            annotState.startX = e.clientX - rect.left;
            annotState.startY = e.clientY - rect.top;

            if (['highlight', 'underline', 'strikethrough', 'arrow', 'rectangle', 'circle'].includes(annotState.tool)) {
                annotState.isDrawing = true;
            } else if (annotState.tool === 'draw') {
                annotState.isDrawing = true;
                annotState.drawPoints = [{ x: annotState.startX, y: annotState.startY }];
            } else if (['youtube', 'audio', 'link'].includes(annotState.tool)) {
                const url = prompt(annotState.tool === 'youtube' ? "Ingrese URL del Video de YouTube:" :
                    annotState.tool === 'audio' ? "Ingrese URL del Archivo de Audio:"
                        : "Ingrese Enlace Web:");
                if (url) {
                    const w = annotState.tool === 'youtube' ? 120 : 60;
                    const h = annotState.tool === 'youtube' ? 90 : 60;
                    annotState.annotations.push({
                        type: annotState.tool,
                        page: annotState.currentPage,
                        x: annotState.startX - w / 2,
                        y: annotState.startY - h / 2,
                        width: w,
                        height: h,
                        url: url,
                        color: annotState.tool === 'link' ? '#0000ff' : '#ff0000',
                        vWidth: layer.width,
                        vHeight: layer.height
                    });
                    redrawAnnotations();
                    setTool('cursor');
                }
            } else if (annotState.tool === 'eraser' || annotState.tool === 'eraserMedia') {
                const x = annotState.startX;
                const y = annotState.startY;
                for (let i = annotState.annotations.length - 1; i >= 0; i--) {
                    const ann = annotState.annotations[i];
                    if (ann.page !== annotState.currentPage) continue;
                    if (isPointInAnnotation(x, y, ann)) {
                        annotState.annotations.splice(i, 1);
                        redrawAnnotations();
                        break;
                    }
                }
            } else if (annotState.tool === 'text') {
                const text = prompt("Ingrese texto:");
                if (text) {
                    annotState.annotations.push({
                        type: 'text',
                        page: annotState.currentPage,
                        x: annotState.startX,
                        y: annotState.startY,
                        text: text,
                        color: annotState.color,
                        font: annotState.font,
                        fontSize: annotState.fontSize,
                        vWidth: layer.width,
                        vHeight: layer.height
                    });
                    redrawAnnotations();
                }
            } else if (annotState.tool === 'note') {
                const text = prompt("Ingrese nota:");
                if (text) {
                    annotState.annotations.push({
                        type: 'note',
                        page: annotState.currentPage,
                        x: annotState.startX,
                        y: annotState.startY,
                        text: text,
                        color: annotState.color,
                        fontSize: annotState.fontSize,
                        vWidth: layer.width,
                        vHeight: layer.height
                    });
                    redrawAnnotations();
                }
            }
        }

        function handleMouseMove(e) {
            if (!annotState.isDrawing) return;
            const rect = document.getElementById('annotationLayer').getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (annotState.tool === 'draw') {
                annotState.drawPoints.push({ x: mouseX, y: mouseY });
            }
            redrawAnnotations();
            drawPreview(mouseX, mouseY);
        }

        function handleMouseUp(e) {
            if (!annotState.isDrawing) return;
            annotState.isDrawing = false;

            const rect = document.getElementById('annotationLayer').getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const width = mouseX - annotState.startX;
            const height = mouseY - annotState.startY;

            const annotation = {
                type: annotState.tool,
                page: annotState.currentPage,
                x: Math.min(annotState.startX, mouseX),
                y: Math.min(annotState.startY, mouseY),
                width: Math.abs(width),
                height: Math.abs(height),
                color: annotState.color,
                lineWidth: annotState.lineWidth,
                vWidth: layer.width,
                vHeight: layer.height
            };

            if (annotState.tool === 'arrow') {
                annotation.x1 = annotState.startX;
                annotation.y1 = annotState.startY;
                annotation.x2 = mouseX;
                annotation.y2 = mouseY;
            } else if (annotState.tool === 'draw') {
                annotation.points = annotState.drawPoints;
                annotState.drawPoints = [];
            }

            if (annotation.width > 2 || annotation.height > 2 ||
                annotState.tool === 'draw' || annotState.tool === 'arrow') {
                annotState.annotations.push(annotation);
            }

            redrawAnnotations();
        }

        function isPointInAnnotation(x, y, ann) {
            const buffer = 5;
            if (ann.type === 'draw') {
                if (!ann.points) return false;
                for (const pt of ann.points) {
                    if (Math.hypot(pt.x - x, pt.y - y) < 10) return true;
                }
                return false;
            }
            if (['youtube', 'audio', 'link'].includes(ann.type)) {
                return (x >= ann.x && x <= ann.x + ann.width &&
                    y >= ann.y && y <= ann.y + ann.height);
            }
            if (ann.width !== undefined && ann.height !== undefined) {
                return (x >= ann.x - buffer && x <= ann.x + ann.width + buffer &&
                    y >= ann.y - buffer && y <= ann.y + ann.height + buffer);
            }
            if (ann.type === 'text' || ann.type === 'note') {
                return (x >= ann.x && x <= ann.x + 100 && y >= ann.y - 20 && y <= ann.y + 5);
            }
            return false;
        }

        function drawPreview(mouseX, mouseY) {
            const layer = document.getElementById('annotationLayer');
            const ctx = layer.getContext('2d');
            const width = mouseX - annotState.startX;
            const height = mouseY - annotState.startY;

            ctx.save();
            ctx.strokeStyle = annotState.color;
            ctx.fillStyle = annotState.color;
            ctx.lineWidth = annotState.lineWidth;

            if (annotState.tool === 'highlight') {
                ctx.globalAlpha = 0.3;
                ctx.fillRect(annotState.startX, annotState.startY, width, height);
            } else if (annotState.tool === 'underline') {
                ctx.beginPath();
                ctx.moveTo(annotState.startX, annotState.startY + height);
                ctx.lineTo(mouseX, annotState.startY + height);
                ctx.stroke();
            } else if (annotState.tool === 'strikethrough') {
                const midY = annotState.startY + height / 2;
                ctx.beginPath();
                ctx.moveTo(annotState.startX, midY);
                ctx.lineTo(mouseX, midY);
                ctx.stroke();
            } else if (annotState.tool === 'arrow') {
                drawArrow(ctx, annotState.startX, annotState.startY, mouseX, mouseY, annotState.color);
            } else if (annotState.tool === 'rectangle') {
                ctx.strokeRect(annotState.startX, annotState.startY, width, height);
            } else if (annotState.tool === 'circle') {
                const radiusX = Math.abs(width) / 2;
                const radiusY = Math.abs(height) / 2;
                const centerX = annotState.startX + width / 2;
                const centerY = annotState.startY + height / 2;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                ctx.stroke();
            } else if (annotState.tool === 'draw') {
                ctx.beginPath();
                if (annotState.drawPoints && annotState.drawPoints.length > 0) {
                    ctx.moveTo(annotState.drawPoints[0].x, annotState.drawPoints[0].y);
                    for (let i = 1; i < annotState.drawPoints.length; i++) {
                        ctx.lineTo(annotState.drawPoints[i].x, annotState.drawPoints[i].y);
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function drawArrow(ctx, x1, y1, x2, y2, color) {
            const headLength = 15;
            const angle = Math.atan2(y2 - y1, x2 - x1);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function redrawAnnotations() {
            const layer = document.getElementById('annotationLayer');
            const ctx = layer.getContext('2d');
            ctx.clearRect(0, 0, layer.width, layer.height);

            annotState.annotations.forEach(ann => {
                if (ann.page !== annotState.currentPage) return;

                ctx.save();
                ctx.strokeStyle = ann.color;
                ctx.fillStyle = ann.color;
                ctx.lineWidth = ann.lineWidth || 2;

                if (ann.type === 'highlight') {
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(ann.x, ann.y, ann.width, ann.height);
                } else if (ann.type === 'underline') {
                    ctx.beginPath();
                    ctx.moveTo(ann.x, ann.y + ann.height);
                    ctx.lineTo(ann.x + ann.width, ann.y + ann.height);
                    ctx.stroke();
                } else if (ann.type === 'strikethrough') {
                    const midY = ann.y + ann.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(ann.x, midY);
                    ctx.lineTo(ann.x + ann.width, midY);
                    ctx.stroke();
                } else if (ann.type === 'arrow') {
                    drawArrow(ctx, ann.x1, ann.y1, ann.x2, ann.y2, ann.color);
                } else if (ann.type === 'rectangle') {
                    ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
                } else if (ann.type === 'circle') {
                    const radiusX = ann.width / 2;
                    const radiusY = ann.height / 2;
                    const centerX = ann.x + radiusX;
                    const centerY = ann.y + radiusY;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (ann.type === 'draw') {
                    if (ann.points && ann.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(ann.points[0].x, ann.points[0].y);
                        for (let i = 1; i < ann.points.length; i++) {
                            ctx.lineTo(ann.points[i].x, ann.points[i].y);
                        }
                        ctx.stroke();
                    }
                } else if (ann.type === 'text') {
                    const fontSize = ann.fontSize || 12;
                    ctx.font = `${fontSize}px ${ann.font || 'Arial'}`;
                    ctx.fillText(ann.text, ann.x, ann.y);
                } else if (ann.type === 'note') {
                    const fontSize = ann.fontSize || 12;
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.fillText("üìù " + ann.text, ann.x, ann.y);
                } else if (['youtube', 'audio', 'link'].includes(ann.type)) {
                    const centerX = ann.x + ann.width / 2;
                    const centerY = ann.y + ann.height / 2;

                    ctx.fillStyle = ann.type === 'youtube' ? '#FF0000' :
                        ann.type === 'audio' ? '#4CAF50' : '#2196F3';
                    ctx.fillRect(ann.x, ann.y, ann.width, ann.height);

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);

                    ctx.fillStyle = 'white';
                    ctx.font = `${Math.min(ann.width, ann.height) / 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const symbol = ann.type === 'youtube' ? '‚ñ∂Ô∏è' :
                        ann.type === 'audio' ? 'üîä' : 'üîó';
                    ctx.fillText(symbol, centerX, centerY);
                }
                ctx.restore();
            });
        }

        async function saveAnnotations() {
            const mode = annotState.mode; // 'annotate' or 'media'
            const resultDivId = mode === 'media' ? 'mediaResult' : 'annotateResult';
            const downloadLinkId = mode === 'media' ? 'mediaDownload' : 'annotateDownload';
            const btnSelector = mode === 'media' ? '#mediaBtn' : '#annotateBtn';

            const btn = document.querySelector(btnSelector);
            const originalText = btn.textContent;
            btn.textContent = " Procesando...";
            btn.disabled = true;

            try {
                // 1. Cargar el PDF original
                const bytes = await readPdfBytes(annotState.file);
                const pdfDoc = await PDFLib.PDFDocument.load(bytes, { ignoreEncryption: true });
                const newPdf = await PDFLib.PDFDocument.create();

                // 2. Embeber fuentes
                const fontMap = {
                    'Helvetica': await newPdf.embedFont(PDFLib.StandardFonts.Helvetica),
                    'Helvetica-Bold': await newPdf.embedFont(PDFLib.StandardFonts.HelveticaBold),
                    'Helvetica-Oblique': await newPdf.embedFont(PDFLib.StandardFonts.HelveticaOblique),
                    'Helvetica-BoldOblique': await newPdf.embedFont(PDFLib.StandardFonts.HelveticaBoldOblique),
                    'Times-Roman': await newPdf.embedFont(PDFLib.StandardFonts.TimesRoman),
                    'Times-Bold': await newPdf.embedFont(PDFLib.StandardFonts.TimesRomanBold),
                    'Times-Italic': await newPdf.embedFont(PDFLib.StandardFonts.TimesRomanItalic),
                    'Times-BoldItalic': await newPdf.embedFont(PDFLib.StandardFonts.TimesRomanBoldItalic),
                    'Courier': await newPdf.embedFont(PDFLib.StandardFonts.Courier),
                    'Courier-Bold': await newPdf.embedFont(PDFLib.StandardFonts.CourierBold),
                    'Courier-Oblique': await newPdf.embedFont(PDFLib.StandardFonts.CourierOblique),
                    'Courier-BoldOblique': await newPdf.embedFont(PDFLib.StandardFonts.CourierBoldOblique)
                };

                // 3. Copiar p√°ginas
                const pageIndices = pdfDoc.getPageIndices();
                const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(page => newPdf.addPage(page));
                const pages = newPdf.getPages();

                // 4. Aplicar anotaciones
                for (const ann of annotState.annotations) {
                    const pageIndex = ann.page - 1;
                    if (pageIndex < 0 || pageIndex >= pages.length) continue;

                    const page = pages[pageIndex];
                    const { width, height } = page.getSize();
                    const rotation = page.getRotation().angle;

                    // Colores
                    const rgb = ann.color ? hexToRgb(ann.color) : { r: 0, g: 0, b: 0 };
                    const color = PDFLib.rgb(rgb.r, rgb.g, rgb.b);

                    // Coordenadas
                    const vX1 = ann.x;
                    const vY1 = ann.y;
                    const vX2 = ann.x + (ann.width || 0);
                    const vY2 = ann.y + (ann.height || 0);

                    const p1 = transformCoordinates(vX1, vY1, ann.vWidth, ann.vHeight, width, height, rotation);
                    const p2 = transformCoordinates(vX2, vY2, ann.vWidth, ann.vHeight, width, height, rotation);

                    const physX = Math.min(p1.x, p2.x);
                    const physY = Math.min(p1.y, p2.y);
                    const physW = Math.abs(p1.x - p2.x);
                    const physH = Math.abs(p1.y - p2.y);

                    if (['youtube', 'audio', 'link'].includes(ann.type)) {
                        // Draw Visual
                        page.drawRectangle({
                            x: physX, y: physY, width: physW, height: physH,
                            color: ann.type === 'youtube' ? PDFLib.rgb(1, 0, 0) :
                                ann.type === 'audio' ? PDFLib.rgb(0.3, 0.7, 0.3) : PDFLib.rgb(0.1, 0.6, 1),
                            borderColor: PDFLib.rgb(1, 1, 1), borderWidth: 2
                        });

                        const label = ann.type === 'youtube' ? "VIDEO" : ann.type === 'audio' ? "AUDIO" : "LINK";
                        page.drawText(label, {
                            x: physX + 5, y: physY + physH / 2 - 5, size: 10,
                            font: fontMap['Helvetica-Bold'], color: PDFLib.rgb(1, 1, 1)
                        });

                        // Add Link Annotation
                        // Note: pdf-lib link annotation support is low-level.
                        const link = newPdf.context.register(
                            newPdf.context.obj({
                                Type: 'Annot', Subtype: 'Link',
                                Rect: [physX, physY, physX + physW, physY + physH],
                                Border: [0, 0, 0],
                                A: { Type: 'Action', S: 'URI', URI: ann.url }
                            })
                        );

                        let annots = page.node.Annots();
                        if (!annots) {
                            annots = newPdf.context.obj([]);
                            page.node.set(PDFLib.PDFName.of('Annots'), annots);
                        }
                        annots.push(link);

                    } else if (ann.type === 'highlight') {
                        page.drawRectangle({
                            x: physX, y: physY, width: physW, height: physH,
                            color: color, opacity: 0.3
                        });
                    } else if (ann.type === 'rectangle') {
                        page.drawRectangle({
                            x: physX, y: physY, width: physW, height: physH,
                            borderColor: color, borderWidth: ann.lineWidth || 2
                        });
                    } else if (ann.type === 'circle') {
                        page.drawEllipse({
                            x: physX + physW / 2, y: physY + physH / 2,
                            xScale: physW / 2, yScale: physH / 2,
                            borderColor: color, borderWidth: ann.lineWidth || 2
                        });
                    } else if (ann.type === 'underline') {
                        // Simple approximation bottom line
                        page.drawLine({
                            start: { x: physX, y: physY },
                            end: { x: physX + physW, y: physY },
                            thickness: ann.lineWidth || 2, color: color
                        });
                    } else if (ann.type === 'strikethrough') {
                        // Mid line
                        page.drawLine({
                            start: { x: physX, y: physY + physH / 2 },
                            end: { x: physX + physW, y: physY + physH / 2 },
                            thickness: ann.lineWidth || 2, color: color
                        });
                    } else if (ann.type === 'arrow') {
                        // Recalculate arrow points
                        if (ann.x1 !== undefined) {
                            const start = transformCoordinates(ann.x1, ann.y1, ann.vWidth, ann.vHeight, width, height, rotation);
                            const end = transformCoordinates(ann.x2, ann.y2, ann.vWidth, ann.vHeight, width, height, rotation);
                            drawArrowOnPage(page, start, end, color, ann.lineWidth || 2);
                        }
                    } else if (ann.type === 'draw') {
                        if (ann.points && ann.points.length > 1) {
                            for (let i = 0; i < ann.points.length - 1; i++) {
                                const pt1 = transformCoordinates(ann.points[i].x, ann.points[i].y, ann.vWidth, ann.vHeight, width, height, rotation);
                                const pt2 = transformCoordinates(ann.points[i + 1].x, ann.points[i + 1].y, ann.vWidth, ann.vHeight, width, height, rotation);
                                page.drawLine({ start: pt1, end: pt2, thickness: ann.lineWidth || 2, color: color });
                            }
                        }
                    } else if (ann.type === 'text' || ann.type === 'note') {
                        const fontScale = (rotation === 0 || rotation === 180) ? height / ann.vHeight : width / ann.vHeight;
                        const fontSize = (ann.fontSize || 12) * fontScale;
                        const font = fontMap[ann.font] || fontMap['Helvetica'];
                        const textContent = ann.type === 'note' ? "Nota: " + ann.text : ann.text;

                        // Approx baseline adjust
                        const textPos = transformCoordinates(ann.x, ann.y + (ann.fontSize || 12), ann.vWidth, ann.vHeight, width, height, rotation);
                        const textRotation = PDFLib.degrees(-rotation);

                        page.drawText(textContent, {
                            x: textPos.x, y: textPos.y, size: fontSize, font: font, color: color, rotate: textRotation
                        });
                    }
                }

                // Save
                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                const link = document.getElementById(downloadLinkId);
                link.href = url;
                link.download = "multimedia_" + annotState.file.name;

                document.getElementById(resultDivId).style.display = 'block';
                closeModal();

            } catch (e) {
                console.error(e);
                alert("Error guardando PDF: " + e.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function transformCoordinates(vx, vy, vW, vH, pW, pH, rotation) {
            const nX = vx / vW;
            const nY = vy / vH;
            let px, py;

            if (rotation === 0) {
                px = nX * pW;
                py = (1 - nY) * pH;
            } else if (rotation === 90) {
                px = nY * pW;
                py = (1 - nX) * pH; // Corrected logic approx
            } else if (rotation === 180) {
                px = (1 - nX) * pW;
                py = nY * pH;
            } else if (rotation === 270 || rotation === -90) {
                px = (1 - nY) * pW;
                py = nX * pH; // Corrected logic approx
            } else {
                px = nX * pW;
                py = (1 - nY) * pH;
            }
            return { x: px, y: py };
        }

        function drawArrowOnPage(page, start, end, color, thickness) {
            page.drawLine({ start: start, end: end, thickness: thickness, color: color });
            // Head (simplified)
            // Ideally calculate angles but for now just line
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 0, g: 0, b: 0 };
        }

        // --- Search Logic Reconstructed ---

        let searchResultData = null;

        function normalizeText(text) {
            return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        async function searchAndExtract() {
            const input = document.getElementById('searchFileInput');
            const query = document.getElementById('searchQuery').value.trim();
            const logs = document.getElementById('searchLogs');
            const resultArea = document.getElementById('searchResult');
            const previewArea = document.getElementById('searchPreview');
            const btn = document.getElementById('searchBtn');
            const password = document.getElementById('searchFilePass').value;

            if (!input.files.length) return;
            if (!query) { alert("Introduce texto."); return; }

            btn.disabled = true;
            btn.textContent = "Buscando...";
            resultArea.style.display = 'none';
            previewArea.style.display = 'none';
            logs.textContent = "Cargando...";

            try {
                const file = input.files[0];
                const bytes = await readPdfBytes(file);
                const normalizedQuery = normalizeText(query);

                const loadingTask = pdfjsLib.getDocument({ data: bytes, password: password });
                const pdfJsDoc = await loadingTask.promise;
                const totalPages = pdfJsDoc.numPages;
                const matchingPages = [];

                logs.textContent = `Analizando ${totalPages} p√°ginas...`;

                for (let i = 1; i <= totalPages; i++) {
                    if (i % 5 === 0) logs.textContent = `Analizando ${i}/${totalPages}...`;

                    const page = await pdfJsDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    const normalizedPageText = normalizeText(pageText);

                    if (normalizedPageText.includes(normalizedQuery)) {
                        const index = normalizedPageText.indexOf(normalizedQuery);
                        const contextStart = Math.max(0, index - 30);
                        const contextEnd = Math.min(pageText.length, index + query.length + 30);
                        const context = pageText.substring(contextStart, contextEnd).trim();

                        matchingPages.push({
                            pageNum: i,
                            index: i - 1,
                            context: context,
                            selected: true
                        });
                    }
                }
                pdfJsDoc.destroy();

                if (matchingPages.length === 0) {
                    logs.textContent = "No se encontraron coinciciencias.";
                    alert("No encontrado.");
                } else {
                    searchResultData = {
                        bytes: bytes,
                        password: password,
                        matchingPages: matchingPages
                    };
                    displaySearchResults(matchingPages);
                    logs.textContent = `Encontradas ${matchingPages.length} p√°ginas.`;
                }

            } catch (error) {
                console.error(error);
                alert("Error: " + error.message);
                logs.textContent = "Error.";
            } finally {
                btn.disabled = false;
                btn.textContent = "Buscar P√°ginas";
            }
        }

        function displaySearchResults(matchingPages) {
            const previewArea = document.getElementById('searchPreview');
            const pagesList = document.getElementById('searchPagesList');
            pagesList.innerHTML = '';

            matchingPages.forEach((pageData, idx) => {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'padding: 10px; margin-bottom: 8px; background: white; border: 1px solid var(--border); border-radius: 4px;';
                itemDiv.innerHTML = `
                    <label style="display: flex; align-items: start; cursor: pointer; gap: 10px;">
                        <input type="checkbox" id="searchPage${idx}" 
                            ${pageData.selected ? 'checked' : ''} 
                            onchange="toggleSearchPage(${idx})"
                            style="margin-top: 3px;">
                        <div style="flex: 1;">
                            <strong>P√°gina ${pageData.pageNum}</strong>
                            <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 4px;">
                                ...${pageData.context}...
                            </div>
                        </div>
                    </label>
                `;
                pagesList.appendChild(itemDiv);
            });
            previewArea.style.display = 'block';
        }

        function toggleSearchPage(idx) {
            if (searchResultData && searchResultData.matchingPages[idx]) {
                const checkbox = document.getElementById(`searchPage${idx}`);
                searchResultData.matchingPages[idx].selected = checkbox.checked;
            }
        }

        function cancelSearch() {
            document.getElementById('searchPreview').style.display = 'none';
            searchResultData = null;
        }

        function waitAndClearMemory(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function extractFoundPages() {
            if (!searchResultData) return;

            const outputName = document.getElementById('searchOutputName').value || 'busqueda.pdf';
            const useRasterMode = document.getElementById('searchRasterMode').checked;
            const logs = document.getElementById('searchLogs');
            const resultArea = document.getElementById('searchResult');
            const extractBtn = document.getElementById('extractFoundBtn');

            // Obtener solo las p√°ginas seleccionadas
            const selectedPages = searchResultData.matchingPages.filter(p => p.selected);

            if (selectedPages.length === 0) {
                alert("Debe seleccionar al menos una p√°gina.");
                return;
            }

            extractBtn.disabled = true;
            extractBtn.textContent = "Extrayendo...";
            resultArea.style.display = 'none';

            try {
                const bytes = searchResultData.bytes;
                const password = searchResultData.password;
                const selectedIndices = selectedPages.map(p => p.index);

                logs.textContent = `Extrayendo ${selectedPages.length} p√°ginas...`;

                if (useRasterMode) {
                    // Modo compatibilidad: renderizar como im√°genes
                    await extractPagesAsImages(bytes, password, selectedIndices, outputName, logs, resultArea);
                } else {
                    // Modo normal: copiar p√°ginas
                    const pdfDoc = await loadPdfWithPasswordFallback(bytes, password);
                    const newPdf = await PDFLib.PDFDocument.create();

                    const copiedPages = await newPdf.copyPages(pdfDoc, selectedIndices);
                    copiedPages.forEach(p => newPdf.addPage(p));

                    const pdfBytes = await newPdf.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });

                    const url = URL.createObjectURL(blob);
                    const link = document.getElementById('searchDownload');
                    link.href = url;
                    link.download = outputName;

                    resultArea.style.display = 'block';
                    logs.textContent = "¬°Proceso terminado exitosamente!";
                }

                // Ocultar preview
                document.getElementById('searchPreview').style.display = 'none';

            } catch (error) {
                console.error(error);
                alert("Error durante la extracci√≥n: " + error.message);
                logs.textContent = "Error en extracci√≥n.";
            } finally {
                extractBtn.disabled = false;
                extractBtn.textContent = "Extraer P√°ginas Seleccionadas";
            }
        }

        async function extractPagesAsImages(bytes, password, pageIndices, outputName, logs, resultArea) {
            logs.textContent = "Cargando PDF en modo compatibilidad...";

            const loadingTask = pdfjsLib.getDocument({
                data: bytes,
                password: password || undefined
            });
            const pdfJsDoc = await loadingTask.promise;

            const newPdf = await PDFLib.PDFDocument.create();
            const scale = 1.5;

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { willReadFrequently: false, alpha: false });

            for (let i = 0; i < pageIndices.length; i++) {
                const pageNum = pageIndices[i] + 1; // pageIndices is 0-indexed
                logs.textContent = `Renderizando p√°gina ${pageNum} (${i + 1}/${pageIndices.length})...`;

                const page = await pdfJsDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: scale });

                canvas.height = viewport.height;
                canvas.width = viewport.width;

                context.clearRect(0, 0, canvas.width, canvas.height);
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;

                const imgDataUrl = canvas.toDataURL('image/jpeg', 0.92);
                const response = await fetch(imgDataUrl);
                const imgBytes = await response.arrayBuffer();
                const jpegImage = await newPdf.embedJpg(imgBytes);

                const newPage = newPdf.addPage([viewport.width, viewport.height]);
                newPage.drawImage(jpegImage, {
                    x: 0,
                    y: 0,
                    width: viewport.width,
                    height: viewport.height,
                });

                page.cleanup();

                if ((i + 1) % 5 === 0) {
                    await waitAndClearMemory(30);
                }
            }

            canvas.width = 0;
            canvas.height = 0;
            pdfJsDoc.destroy();

            logs.textContent = "Guardando PDF...";
            const pdfBytes = await newPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            const link = document.getElementById('searchDownload');
            link.href = url;
            link.download = outputName;

            resultArea.style.display = 'block';
            logs.textContent = "¬°Proceso terminado exitosamente!";
        }

        // --- CHAPTERS EXTRACTION LOGIC ---
        let chaptersData = null;

        async function detectChapters() {
            const input = document.getElementById('chaptersFileInput');
            const patterns = document.getElementById('chapterPattern').value.trim();
            const useNumbers = document.getElementById('chapterUseNumbers').checked;
            const logs = document.getElementById('chaptersLogs');
            const previewArea = document.getElementById('chaptersPreview');
            const resultArea = document.getElementById('chaptersResult');
            const btn = document.getElementById('chaptersBtn');
            const password = document.getElementById('chaptersFilePass').value;

            if (!input.files.length) return;
            if (!patterns) {
                alert("Ingrese al menos un patr√≥n de b√∫squeda.");
                return;
            }

            btn.disabled = true;
            btn.textContent = "Detectando...";
            previewArea.style.display = 'none';
            resultArea.style.display = 'none';
            logs.textContent = "Cargando documento...";

            try {
                const file = input.files[0];
                const bytes = await readPdfBytes(file);

                // Convertir patrones a array
                const patternList = patterns.split(',').map(p => p.trim()).filter(p => p);

                logs.textContent = "Analizando estructura del documento...";

                const loadingTask = pdfjsLib.getDocument({ data: bytes, password: password });
                const pdfJsDoc = await loadingTask.promise;
                const totalPages = pdfJsDoc.numPages;

                const chapters = [];
                logs.textContent = `Buscando cap√≠tulos en ${totalPages} p√°ginas...`;

                // Patr√≥n regex para n√∫meros romanos y ar√°bigos
                const numberPatterns = useNumbers ?
                    /(\d+|I{1,3}|IV|V|VI{0,3}|IX|X{1,3}|XI{0,3}|XIV|XV|XVI{0,3}|XIX|XX)/i : null;

                for (let i = 1; i <= totalPages; i++) {
                    if (i % 10 === 0) logs.textContent = `Analizando p√°gina ${i}/${totalPages}...`;

                    const page = await pdfJsDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');

                    // Buscar cada patr√≥n
                    for (const pattern of patternList) {
                        const normalizedPattern = normalizeText(pattern);
                        const normalizedText = normalizeText(pageText);

                        let regex;
                        if (useNumbers) {
                            // Buscar patr√≥n seguido de n√∫mero
                            regex = new RegExp(normalizedPattern + '\\s*' + numberPatterns.source, 'gi');
                        } else {
                            // Buscar solo el patr√≥n
                            regex = new RegExp(normalizedPattern, 'gi');
                        }

                        const matches = [...normalizedText.matchAll(regex)];

                        if (matches.length > 0) {
                            // Extraer el t√≠tulo completo del cap√≠tulo
                            const match = matches[0];
                            const matchIndex = match.index;

                            // Buscar en texto original (no normalizado) para obtener t√≠tulo real
                            let titleStart = matchIndex;
                            let titleEnd = Math.min(pageText.length, matchIndex + 100);

                            // Buscar hasta punto, nueva l√≠nea o fin de texto
                            const titleText = pageText.substring(titleStart, titleEnd);
                            const endMarkers = ['\n', '.', '   ']; // 3 spaces as potential break
                            let actualEnd = titleText.length;

                            for (const marker of endMarkers) {
                                const idx = titleText.indexOf(marker, pattern.length);
                                if (idx > 0 && idx < actualEnd) {
                                    actualEnd = idx;
                                }
                            }

                            const chapterTitle = pageText.substring(titleStart, titleStart + actualEnd).trim();

                            // Evitar duplicados en la misma p√°gina
                            if (!chapters.find(ch => ch.startPage === i)) {
                                chapters.push({
                                    title: chapterTitle,
                                    startPage: i,
                                    endPage: null, // Se calcular√° despu√©s
                                    selected: true
                                });
                            }
                        }
                    }
                }

                pdfJsDoc.destroy();

                if (chapters.length === 0) {
                    logs.textContent = "No se detectaron cap√≠tulos.";
                    alert("No se encontraron cap√≠tulos con los patrones especificados.");
                    return;
                }

                // Calcular p√°ginas finales
                for (let i = 0; i < chapters.length; i++) {
                    if (i < chapters.length - 1) {
                        chapters[i].endPage = chapters[i + 1].startPage - 1;
                    } else {
                        chapters[i].endPage = totalPages;
                    }
                }

                // Guardar datos
                chaptersData = {
                    bytes: bytes,
                    password: password,
                    chapters: chapters,
                    totalPages: totalPages
                };

                displayChapters(chapters);
                logs.textContent = `Detectados ${chapters.length} cap√≠tulos. Revise y confirme la extracci√≥n.`;

            } catch (error) {
                console.error(error);
                alert("Error durante la detecci√≥n: " + error.message);
                logs.textContent = "Error.";
            } finally {
                btn.disabled = false;
                btn.textContent = "Detectar Cap√≠tulos";
            }
        }

        function displayChapters(chapters) {
            const previewArea = document.getElementById('chaptersPreview');
            const chaptersList = document.getElementById('chaptersList');
            chaptersList.innerHTML = '';

            chapters.forEach((chapter, idx) => {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'padding: 12px; margin-bottom: 10px; background: white; border: 1px solid var(--border); border-radius: 4px;';

                const pageCount = chapter.endPage - chapter.startPage + 1;

                itemDiv.innerHTML = `
                            <label style="display: flex; align-items: start; cursor: pointer; gap: 10px;">
                                <input type="checkbox" id="chapter${idx}" ${chapter.selected ? 'checked' : ''} onchange="toggleChapter(${idx})" style="margin-top: 3px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; margin-bottom: 4px;">
                                        ${chapter.title || 'Cap√≠tulo ' + (idx + 1)}
                                    </div>
                                    <div style="font-size: 0.85rem; color: var(--text-muted);">
                                        P√°ginas ${chapter.startPage} - ${chapter.endPage} (${pageCount} p√°gina${pageCount > 1 ? 's' : ''})
                                    </div>
                                </div>
                                <button class="btn" onclick="event.stopPropagation(); extractSingleChapter(${idx})" style="padding: 6px 12px; font-size: 0.85rem; width: auto;">
                                    Extraer
                                </button>
                            </label>
                        `;

                chaptersList.appendChild(itemDiv);
            });

            previewArea.style.display = 'block';
        }

        function toggleChapter(idx) {
            if (chaptersData && chaptersData.chapters[idx]) {
                const checkbox = document.getElementById(`chapter${idx}`);
                chaptersData.chapters[idx].selected = checkbox.checked;
            }
        }

        function cancelChapters() {
            document.getElementById('chaptersPreview').style.display = 'none';
            chaptersData = null;
        }

        async function extractSingleChapter(idx) {
            if (!chaptersData) return;

            const chapter = chaptersData.chapters[idx];
            const logs = document.getElementById('chaptersLogs');

            try {
                logs.textContent = `Extrayendo "${chapter.title}"...`;

                const useRasterMode = document.getElementById('chapterRasterMode').checked;
                const fileName = sanitizeFilename(chapter.title || `Capitulo_${idx + 1}`) + '.pdf';

                await extractChapter(
                    chaptersData.bytes,
                    chaptersData.password,
                    chapter,
                    fileName,
                    useRasterMode,
                    logs
                );

                logs.textContent = `"${chapter.title}" extra√≠do correctamente.`;

            } catch (error) {
                console.error(error);
                alert("Error extrayendo cap√≠tulo: " + error.message);
                logs.textContent = "Error.";
            }
        }

        async function extractAllChapters() {
            if (!chaptersData) return;

            const selectedChapters = chaptersData.chapters.filter(ch => ch.selected);

            if (selectedChapters.length === 0) {
                alert("Debe seleccionar al menos un cap√≠tulo.");
                return;
            }

            const logs = document.getElementById('chaptersLogs');
            const resultArea = document.getElementById('chaptersResult');
            const linksContainer = document.getElementById('chaptersDownloadLinks');
            const extractBtn = document.getElementById('extractAllChaptersBtn');

            extractBtn.disabled = true;
            extractBtn.textContent = "Extrayendo...";
            resultArea.style.display = 'none';
            linksContainer.innerHTML = '';

            const useRasterMode = document.getElementById('chapterRasterMode').checked;
            const downloadLinks = [];

            try {
                for (let i = 0; i < selectedChapters.length; i++) {
                    const chapter = selectedChapters[i];
                    logs.textContent = `Extrayendo cap√≠tulo ${i + 1}/${selectedChapters.length}: "${chapter.title}"...`;

                    const fileName = sanitizeFilename(chapter.title || `Capitulo_${i + 1}`) + '.pdf';

                    const url = await extractChapter(
                        chaptersData.bytes,
                        chaptersData.password,
                        chapter,
                        fileName,
                        useRasterMode,
                        logs,
                        true // returnURL
                    );

                    downloadLinks.push({ title: chapter.title, url: url, filename: fileName });

                    // Peque√±a pausa entre cap√≠tulos
                    await waitAndClearMemory(100);
                }

                // Mostrar enlaces de descarga
                linksContainer.innerHTML = '';
                downloadLinks.forEach(link => {
                    const linkDiv = document.createElement('div');
                    linkDiv.style.cssText = 'margin-bottom: 8px;';
                    linkDiv.innerHTML = `
                                <a href="${link.url}" download="${link.filename}" style="color: var(--primary); text-decoration: none; font-weight: 500;">
                                    üìÑ ${link.title || link.filename}
                                </a>
                            `;
                    linksContainer.appendChild(linkDiv);
                });

                resultArea.style.display = 'block';
                document.getElementById('chaptersResultText').textContent = `¬°√âxito! Se han generado ${downloadLinks.length} cap√≠tulos. Haga clic en los enlaces para descargar:`;
                logs.textContent = "Todos los cap√≠tulos extra√≠dos correctamente.";

                // Ocultar preview
                document.getElementById('chaptersPreview').style.display = 'none';

            } catch (error) {
                console.error(error);
                alert("Error durante la extracci√≥n: " + error.message);
                logs.textContent = "Error.";
            } finally {
                extractBtn.disabled = false;
                extractBtn.textContent = "üìö Extraer Todos los Cap√≠tulos";
            }
        }

        async function extractChapter(bytes, password, chapter, fileName, useRasterMode, logs, returnURL = false) {
            const startIdx = chapter.startPage - 1; // 0-indexed
            const endIdx = chapter.endPage - 1;
            const pageIndices = [];

            for (let i = startIdx; i <= endIdx; i++) {
                pageIndices.push(i);
            }

            let pdfBytes;
            if (useRasterMode) {
                // Modo compatibilidad
                const loadingTask = pdfjsLib.getDocument({
                    data: bytes,
                    password: password || undefined
                });
                const pdfJsDoc = await loadingTask.promise;

                const newPdf = await PDFLib.PDFDocument.create();
                const scale = 1.5;

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d', { willReadFrequently: false, alpha: false });

                for (let i = 0; i < pageIndices.length; i++) {
                    const pageNum = pageIndices[i] + 1;
                    const page = await pdfJsDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: scale });

                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    const imgDataUrl = canvas.toDataURL('image/jpeg', 0.92);
                    const response = await fetch(imgDataUrl);
                    const imgBytes = await response.arrayBuffer();
                    const jpegImage = await newPdf.embedJpg(imgBytes);

                    const newPage = newPdf.addPage([viewport.width, viewport.height]);
                    newPage.drawImage(jpegImage, {
                        x: 0,
                        y: 0,
                        width: viewport.width,
                        height: viewport.height,
                    });

                    page.cleanup();
                }

                canvas.width = 0;
                canvas.height = 0;
                pdfJsDoc.destroy();

                pdfBytes = await newPdf.save();
            } else {
                // Modo normal
                const pdfDoc = await loadPdfWithPasswordFallback(bytes, password);
                const newPdf = await PDFLib.PDFDocument.create();

                const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                copiedPages.forEach(p => newPdf.addPage(p));

                pdfBytes = await newPdf.save();
            }

            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            if (returnURL) {
                return url;
            } else {
                // Descargar inmediatamente
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                return url;
            }
        }

        function sanitizeFilename(filename) {
            // Eliminar caracteres no v√°lidos para nombres de archivo
            return filename.replace(/[<>:"/\\|?*]/g, '_').replace(/\s+/g, '_').substring(0, 100);
        }

        // --- TRANSLATE / READER LOGIC ---

        let translateState = {
            pdfDoc: null,
            currentPage: 1,
            totalPages: 0,
            scale: 1.0,
            autoFit: true,
            textLayer: null
        };

        async function handleTranslateFileBase(input) {
            if (!input.files.length) return;
            const file = input.files[0];
            try {
                const bytes = await readPdfBytes(file);
                const loadingTask = pdfjsLib.getDocument({ data: bytes });
                translateState.pdfDoc = await loadingTask.promise;
                translateState.totalPages = translateState.pdfDoc.numPages;
                translateState.currentPage = 1;

                document.getElementById('transPageLabel').textContent = `1 / ${translateState.totalPages}`;
                renderTranslatePage(1);
            } catch (e) {
                console.error(e);
                alert("Error cargando PDF: " + e.message);
            }
        }

        async function changeTranslatePage(delta) {
            if (!translateState.pdfDoc) return;
            const newPage = translateState.currentPage + delta;
            if (newPage >= 1 && newPage <= translateState.totalPages) {
                translateState.currentPage = newPage;
                document.getElementById('transPageLabel').textContent = `${newPage} / ${translateState.totalPages}`;
                renderTranslatePage(newPage);
            }
        }

        async function renderTranslatePage(pageNum) {
            const pdf = translateState.pdfDoc;
            const page = await pdf.getPage(pageNum);

            // Calculate Scale
            const container = document.getElementById('translateCanvas').parentElement.parentElement;
            const containerWidth = container.clientWidth - 40; // padding

            let scale = translateState.scale;
            if (translateState.autoFit) {
                const unscaledViewport = page.getViewport({ scale: 1.0 });
                scale = containerWidth / unscaledViewport.width;
                translateState.scale = scale; // Sync
            }

            const viewport = page.getViewport({ scale: scale });

            // Canvas
            const canvas = document.getElementById('translateCanvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            // Render Page
            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            await page.render(renderContext).promise;

            // --- Text Layer ---
            const textLayerDiv = document.getElementById('textLayer');
            textLayerDiv.innerHTML = ''; // Clear previous
            textLayerDiv.style.height = viewport.height + 'px';
            textLayerDiv.style.width = viewport.width + 'px';

            const textContent = await page.getTextContent();

            // PDFJS renderTextLayer
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: viewport,
                textDivs: []
            });
        }

        function setTranslateZoom(type) {
            if (type === 'fit') {
                translateState.autoFit = true;
            }
            renderTranslatePage(translateState.currentPage);
        }

        function changeTranslateZoom(delta) {
            translateState.autoFit = false;
            translateState.scale = Math.max(0.5, translateState.scale + delta);
            renderTranslatePage(translateState.currentPage);
        }

        // Translation
        function getSelectedText() {
            const sel = window.getSelection();
            return sel.toString().trim();
        }

        function translateSelection() {
            const text = getSelectedText();
            if (!text) {
                alert("Por favor, selecciona texto del PDF primero.");
                return;
            }
            const lang = document.getElementById('transLang').value;
            const url = `https://translate.google.com/?sl=auto&tl=${lang}&text=${encodeURIComponent(text)}`;
            window.open(url, '_blank');
        }

        // TTS
        let synth = window.speechSynthesis;
        let voices = [];

        function loadVoices() {
            voices = synth.getVoices();
            const select = document.getElementById('ttsVoice');
            select.innerHTML = '';

            voices.forEach((voice, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${voice.name} (${voice.lang})`;

                // Pre-select Google Espa√±ol or similar
                if (voice.name.includes('Google') && voice.lang.includes('es')) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        // Voice loading is async
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }

        // Initial try
        loadVoices();

        function speakSelection() {
            const text = getSelectedText();
            if (!text) {
                alert("Selecciona texto para leer.");
                return;
            }
            stopSpeech();

            const utterance = new SpeechSynthesisUtterance(text);
            const voiceIndex = document.getElementById('ttsVoice').value;
            if (voiceIndex) {
                utterance.voice = voices[voiceIndex];
            }
            utterance.rate = parseFloat(document.getElementById('ttsRate').value);
            synth.speak(utterance);
        }

        function stopSpeech() {
            if (synth.speaking) {
                synth.cancel();
            }
        }

        // --- PODCAST LOGIC ---

        let podcastState = {
            pdfDoc: null,
            currentPage: 1,
            totalPages: 0,
            scale: 1.2,
            audioBlob: null,
            audioUrl: null,
            placementMode: false,
            marker: null, // { page, x, y }
            recorder: null,
            chunks: [],
            timerInterval: null
        };

        async function handlePodcastFileBase(input) {
            if (!input.files.length) return;
            const file = input.files[0];
            try {
                const bytes = await readPdfBytes(file);
                const loadingTask = pdfjsLib.getDocument({ data: bytes });
                podcastState.pdfDoc = await loadingTask.promise;
                podcastState.totalPages = podcastState.pdfDoc.numPages;
                podcastState.currentPage = 1;
                podcastState.marker = null; // reset

                document.getElementById('podcastPageLabel').textContent = `1 / ${podcastState.totalPages}`;
                renderPodcastPage(1);
            } catch (e) {
                console.error(e);
                alert("Error cargando PDF: " + e.message);
            }
        }

        async function changePodcastPage(delta) {
            if (!podcastState.pdfDoc) return;
            const newPage = podcastState.currentPage + delta;
            if (newPage >= 1 && newPage <= podcastState.totalPages) {
                podcastState.currentPage = newPage;
                document.getElementById('podcastPageLabel').textContent = `${newPage} / ${podcastState.totalPages}`;
                renderPodcastPage(newPage);
            }
        }

        async function renderPodcastPage(pageNum) {
            const pdf = podcastState.pdfDoc;
            const page = await pdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: podcastState.scale });

            const canvas = document.getElementById('podcastCanvas');
            const ctx = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            await page.render(renderContext).promise;

            // Draw Marker if on this page
            if (podcastState.marker && podcastState.marker.page === pageNum) {
                const x = podcastState.marker.x;
                const y = podcastState.marker.y;

                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.fillText("üéôÔ∏è", x, y);

                ctx.font = "12px Arial";
                ctx.fillStyle = "red";
                ctx.fillText("Podcast", x, y + 15);
            }

            // Attach click listener only once or handle globally
            canvas.onclick = handlePodcastCanvasClick;
        }

        function handlePodcastCanvasClick(e) {
            if (!podcastState.placementMode) return;

            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            podcastState.marker = {
                page: podcastState.currentPage,
                x: x,
                y: y
            };

            podcastState.placementMode = false;
            document.getElementById('podcastCanvas').style.cursor = 'default';
            renderPodcastPage(podcastState.currentPage);

            document.getElementById('btnSavePodcast').disabled = false;
            alert("Ubicaci√≥n marcada. Ahora puedes guardar el PDF.");
        }

        // Recorder
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                podcastState.recorder = new MediaRecorder(stream);
                podcastState.chunks = [];

                podcastState.recorder.ondataavailable = e => podcastState.chunks.push(e.data);
                podcastState.recorder.onstop = e => {
                    const blob = new Blob(podcastState.chunks, { type: 'audio/webm' }); // or mp3
                    podcastState.audioBlob = blob;
                    podcastState.audioUrl = URL.createObjectURL(blob);

                    // Preview
                    const audio = document.getElementById('audioPreview');
                    audio.src = podcastState.audioUrl;
                    document.getElementById('audioPreviewContainer').style.display = 'block';
                };

                podcastState.recorder.start();
                startVisualizer(stream);
                startTimer();

                document.getElementById('btnRecordStart').disabled = true;
                document.getElementById('btnRecordStop').disabled = false;
                document.getElementById('btnRecordStart').classList.add('recording-active');

            } catch (e) {
                alert("No se pudo acceder al micr√≥fono: " + e.message + "\nIntenta usar 'Subir archivo' si est√°s en local.");
            }
        }

        function stopRecording() {
            if (podcastState.recorder) {
                podcastState.recorder.stop();
                stopTimer();
                stopVisualizer();

                document.getElementById('btnRecordStart').disabled = false;
                document.getElementById('btnRecordStop').disabled = true;
                document.getElementById('btnRecordStart').classList.remove('recording-active');
            }
        }

        // Visualizer (Simple)
        let audioContext, analyser, dataArray, visualizerId;

        function startVisualizer(stream) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            const canvas = document.getElementById('audioVisualizer');
            const ctx = canvas.getContext('2d');

            function draw() {
                visualizerId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] / 2;
                    ctx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)';
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function stopVisualizer() {
            cancelAnimationFrame(visualizerId);
        }

        // Timer
        let startTime;

        function startTimer() {
            startTime = Date.now();
            podcastState.timerInterval = setInterval(() => {
                const diff = Math.floor((Date.now() - startTime) / 1000);
                const m = Math.floor(diff / 60).toString().padStart(2, '0');
                const s = (diff % 60).toString().padStart(2, '0');
                document.getElementById('recordTimer').textContent = `${m}:${s}`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(podcastState.timerInterval);
        }

        function useRecordedAudio() {
            document.getElementById('btnPlacePodcast').disabled = false;
            alert("Audio grabado seleccionado. Ahora haz clic en 'Colocar en PDF'.");
        }

        function handleAudioUpload(input) {
            if (!input.files.length) return;
            const file = input.files[0];
            podcastState.audioBlob = file; // Use file directly as blob
            document.getElementById('btnPlacePodcast').disabled = false;
            alert("Audio subido seleccionado. Ahora haz clic en 'Colocar en PDF'.");
        }

        function activatePodcastPlacement() {
            if (!podcastState.pdfDoc) {
                alert("Carga un PDF primero");
                return;
            }
            podcastState.placementMode = true;
            document.getElementById('podcastCanvas').style.cursor = 'crosshair';
            alert("Haz clic en la p√°gina donde quieras poner el icono del Podcast.");
        }

        async function savePodcastPDF() {
            if (!podcastState.audioBlob || !podcastState.marker) return;

            const btn = document.getElementById('btnSavePodcast');
            btn.textContent = "Guardando...";
            btn.disabled = true;

            try {
                // 1. Load PDF
                const input = document.getElementById('podcastFileInput');
                const bytes = await readPdfBytes(input.files[0]);
                const pdfDoc = await PDFLib.PDFDocument.load(bytes);

                // 2. Attach File
                // Convert blob to array buffer
                const audioBytes = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(new Uint8Array(reader.result));
                    reader.readAsArrayBuffer(podcastState.audioBlob);
                });

                // 2. Embed Audio File Stream
                const audioRef = pdfDoc.context.register(
                    pdfDoc.context.flateStream(audioBytes, {
                        Type: 'EmbeddedFile',
                        Subtype: 'audio/webm',
                        Params: {
                            Size: audioBytes.length,
                            CreationDate: new Date(),
                        },
                    })
                );

                const fileSpecHash = new Uint8Array(16); // Placeholder hash
                const fileSpecDict = pdfDoc.context.obj({
                    Type: 'Filespec',
                    F: 'podcast_recording.webm',
                    EF: { F: audioRef },
                });

                // 3. Create FileAttachment Annotation
                const page = pdfDoc.getPages()[podcastState.marker.page - 1];
                const { width, height } = page.getSize();

                const pdfX = podcastState.marker.x / podcastState.scale;
                const pdfY = height - (podcastState.marker.y / podcastState.scale);

                const annotInfo = pdfDoc.context.obj({
                    Type: 'Annot',
                    Subtype: 'FileAttachment',
                    Rect: [pdfX, pdfY - 20, pdfX + 20, pdfY], // 20x20 icon
                    FS: fileSpecDict,
                    Name: 'PushPin', // Standard icon for FileAttachment
                    T: 'Podcast Grabado',
                    Contents: 'Haz clic para escuchar el podcast grabado.',
                    C: [1, 0, 0] // Red Color
                });

                const annotRef = pdfDoc.context.register(annotInfo);
                page.node.set(PDFLib.PDFName.of('Annots'), pdfDoc.context.obj([annotRef]));

                // 4. Draw Visual Marker (Backup/Visibility)
                page.drawCircle({
                    x: pdfX + 10, // Center of 20x20 rect
                    y: pdfY - 10,
                    size: 15,
                    color: PDFLib.rgb(1, 0, 0),
                    opacity: 0.3,
                });
                page.drawText('PODCAST', {
                    x: pdfX - 10,
                    y: pdfY - 25,
                    size: 9,
                    color: PDFLib.rgb(1, 0, 0)
                });

                // Save
                const pdfBytes = await pdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = "podcast_doc.pdf";
                a.click();

            } catch (e) {
                console.error(e);
                alert("Error guardando: " + e.message);
            } finally {
                btn.textContent = "üíæ Guardar PDF";
                btn.disabled = false;
            }
        }

        // --- TTS PODCAST LOGIC ---
        let ttsState = {
            pdfDoc: null,
            file: null,
            totalPages: 0,
            currentPage: 1,
            scale: 1.2,
            audioBlob: null,
            audioUrl: null,
            placementMode: false,
            marker: null
        };

        async function handleTTSPodcastFileBase(input) {
            if (!input.files.length) return;
            ttsState.file = input.files[0];
            const bytes = await readPdfBytes(ttsState.file);
            const loadingTask = pdfjsLib.getDocument({ data: bytes });
            ttsState.pdfDoc = await loadingTask.promise;
            ttsState.totalPages = ttsState.pdfDoc.numPages;
            ttsState.currentPage = 1;
            renderTTSPodcastPage(1);

            // Add click listener
            const canvas = document.getElementById('ttsPodcastCanvas');
            canvas.addEventListener('click', handleTTSPodcastCanvasClick);
        }

        async function changeTTSPodcastPage(delta) {
            if (!ttsState.pdfDoc) return;
            const newPage = ttsState.currentPage + delta;
            if (newPage >= 1 && newPage <= ttsState.totalPages) {
                ttsState.currentPage = newPage;
                renderTTSPodcastPage(newPage);
            }
        }

        async function renderTTSPodcastPage(pageNum) {
            if (!ttsState.pdfDoc) return;
            document.getElementById('ttsPodcastPageLabel').textContent = `${pageNum} / ${ttsState.totalPages}`;

            const page = await ttsState.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: ttsState.scale });
            const canvas = document.getElementById('ttsPodcastCanvas');
            const context = canvas.getContext('2d');

            canvas.height = viewport.height;
            canvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport: viewport }).promise;

            // Draw marker if exists on this page
            if (ttsState.marker && ttsState.marker.page === pageNum) {
                context.font = "30px Arial";
                context.fillText("üéôÔ∏è", ttsState.marker.x - 15, ttsState.marker.y);
            }
        }

        function handleTTSPodcastCanvasClick(e) {
            if (!ttsState.placementMode) return;

            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ttsState.marker = {
                page: ttsState.currentPage,
                x: x,
                y: y
            };

            ttsState.placementMode = false;
            e.target.style.cursor = 'default';
            alert("Ubicaci√≥n seleccionada. Ahora puedes guardar.");
            document.getElementById('btnSaveTTSPodcast').disabled = false;

            renderTTSPodcastPage(ttsState.currentPage);
        }

        async function generateTTSAudio() {
            const text = document.getElementById('ttsInputText').value.trim();
            const lang = document.getElementById('ttsLang').value;

            if (!text) {
                alert("Por favor escribe alg√∫n texto.");
                return;
            }

            // Function to split text into chunks
            function chunkText(str, maxLength) {
                const words = str.split(' ');
                const chunks = [];
                let currentChunk = '';

                words.forEach(word => {
                    if ((currentChunk + word).length < maxLength) {
                        currentChunk += (currentChunk ? ' ' : '') + word;
                    } else {
                        chunks.push(currentChunk);
                        currentChunk = word;
                    }
                });
                if (currentChunk) chunks.push(currentChunk);
                return chunks;
            }

            const chunks = chunkText(text, 180); // < 200 chars for safety
            const audioBlobs = [];
            const btn = document.querySelector('[onclick="generateTTSAudio()"]');
            const originalText = btn.textContent;

            btn.disabled = true;

            try {
                for (let i = 0; i < chunks.length; i++) {
                    btn.textContent = `Generando ${i + 1}/${chunks.length}...`;
                    const chunk = chunks[i];
                    // Google TTS API via CORS Proxy
                    const googleUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunk)}&tl=${lang}&client=tw-ob`;
                    const url = `https://api.allorigins.win/raw?url=${encodeURIComponent(googleUrl)}`;

                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Error en el segmento ${i + 1}`);
                    const blob = await response.blob();
                    audioBlobs.push(blob);
                }

                // Concatenate blobs (simple concatenation works for many MP3 streams)
                const finalBlob = new Blob(audioBlobs, { type: 'audio/mpeg' });

                ttsState.audioBlob = finalBlob;
                ttsState.audioUrl = URL.createObjectURL(finalBlob);

                const audio = document.getElementById('ttsAudioPreview');
                audio.src = ttsState.audioUrl;
                document.getElementById('ttsAudioPreviewContainer').style.display = 'block';

                document.getElementById('btnPlaceTTSPodcast').disabled = false;
                alert("Audio generado correctamente. Esc√∫chalo y luego col√≥calo en el PDF.");

            } catch (e) {
                console.error(e);
                alert("Error generando audio: " + e.message);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function activateTTSPodcastPlacement() {
            if (!ttsState.pdfDoc) {
                alert("Carga un PDF primero.");
                return;
            }
            ttsState.placementMode = true;
            document.getElementById('ttsPodcastCanvas').style.cursor = 'crosshair';
            alert("Haz clic en la p√°gina del PDF donde quieras el icono.");
        }

        async function saveTTSPodcastPDF() {
            if (!ttsState.audioBlob || !ttsState.marker) return;
            const btn = document.getElementById('btnSaveTTSPodcast');
            btn.textContent = "Procesando...";
            btn.disabled = true;

            try {
                const input = document.getElementById('ttsPodcastFileInput');
                const bytes = await readPdfBytes(input.files[0]);
                const pdfDoc = await PDFLib.PDFDocument.load(bytes);

                const audioBytes = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(new Uint8Array(reader.result));
                    reader.readAsArrayBuffer(ttsState.audioBlob);
                });

                // 2. Embed Audio File Stream
                const audioRef = pdfDoc.context.register(
                    pdfDoc.context.flateStream(audioBytes, {
                        Type: 'EmbeddedFile',
                        Subtype: 'audio/mpeg',
                        Params: {
                            Size: audioBytes.length,
                            CreationDate: new Date(),
                        },
                    })
                );

                const fileSpecDict = pdfDoc.context.obj({
                    Type: 'Filespec',
                    F: 'podcast_tts.mp3',
                    EF: { F: audioRef },
                });

                // 3. Create FileAttachment Annotation
                const page = pdfDoc.getPages()[ttsState.marker.page - 1];
                const { width, height } = page.getSize();

                const pdfX = ttsState.marker.x / ttsState.scale;
                const pdfY = height - (ttsState.marker.y / ttsState.scale);

                const annotInfo = pdfDoc.context.obj({
                    Type: 'Annot',
                    Subtype: 'FileAttachment',
                    Rect: [pdfX, pdfY - 20, pdfX + 20, pdfY], // 20x20 icon
                    FS: fileSpecDict,
                    Name: 'PushPin', // Standard icon for FileAttachment
                    T: 'Podcast TTS',
                    Contents: 'Haz clic para escuchar el podcast generado.',
                    C: [0, 0, 1] // Blue Color
                });

                const annotRef = pdfDoc.context.register(annotInfo);
                page.node.set(PDFLib.PDFName.of('Annots'), pdfDoc.context.obj([annotRef]));

                // 4. Draw Visual Marker (Backup/Visibility)
                page.drawCircle({
                    x: pdfX + 10,
                    y: pdfY - 10,
                    size: 15,
                    color: PDFLib.rgb(0, 0, 1),
                    opacity: 0.3,
                });
                page.drawText('PODCAST TTS', {
                    x: pdfX - 20,
                    y: pdfY - 25,
                    size: 9,
                    color: PDFLib.rgb(0, 0, 1)
                });

                const pdfBytes = await pdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = "podcast_tts_doc.pdf";
                a.click();

                alert("PDF guardado correctamente.");

            } catch (e) {
                console.error(e);
                alert("Error guardando PDF: " + e.message);
            } finally {
                btn.textContent = "üíæ Guardar PDF";
                btn.disabled = false;
            }
        }
    </script>

</body>

</html>